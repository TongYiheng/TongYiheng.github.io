{"pages":[{"title":"About Me","text":"2019.9- Computer Science and Technology, Shandong University.","link":"/about/index.html"}],"posts":[{"title":"DSA：（一）递归","text":"&emsp;&emsp;递归的核心部分在于找到目标问题的递归部分和基础部分，本文通过求子集和全排列这两个问题来具体分析递归思想的运用。 P1001:子集价值 算法描述&emsp;&emsp;问题包括两个子问题，求子集和序列价值。&emsp;&emsp;求子集：利用标记数组通过0、1标记对应元素是否在子集中，递归部分为从第一个元素开始依次标记，每个元素位置上的标记包括0和1两种情况，通过递归遍历2^n个子集，基础部分为最后一个元素被标记，子集中的元素全部确定。&emsp;&emsp;求序列价值：当子集中的元素确定时，按照标记数组得到子集数组，若标记位为1，子集数组对应元素设置为原数，同时记录子集长度。然后通过子集数组名和子集长度调用价值函数，求出子集价值，返回至上一层。 C++实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;int value(T* p,int cnt)//求序列的价值{ if(cnt==0) return 0; T sum=0; for(int i=0;i&lt;cnt;i++) { sum+=(i+1)*p[i]; } return sum;}template &lt;class T&gt;int subset(T* p,int* mark,int pos,int cnt)//求子集价值的异或和{ int res=0,res1=0,res2=0; //基础部分 if(pos==cnt) { int curr[cnt];//当前的子集 int size=0; for(int i=0;i&lt;cnt;i++) { if(mark[i]==1)//mark标记位为1，取该元素 curr[size++]=p[i]; } res=value(curr,size); return res; } //递归部分 mark[pos]=0; res1=subset(p,mark,pos+1,cnt); mark[pos]=1; res2=subset(p,mark,pos+1,cnt); return res1^res2;}int main(){ int n,result=0; cin&gt;&gt;n; int input[n],flag[n]; //输入n个非负整数 for(int i=0;i&lt;n;i++) { cin&gt;&gt;input[i]; } result=subset(input,flag,0,n); cout&lt;&lt;result; return 0;} 结果分析&emsp;&emsp;在求n个元素的所有子集价值的异或和的问题中，分析递归调用时res1和res2的意义，res1表示在当前位置的元素标记为0和之前位置元素的标记的约束下，满足约束条件的所有子集价值的异或和，res2表示在当前位置的元素标记为1和之前位置元素的标记的约束下，满足约束条件的所有子集价值的异或和。例如，对于{1,2}这个集合，递归的执行步骤如下： 设置元素1标记位mark[0]=0 调用subset 设置元素2标记位mark[1]=0 调用subset，res1接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 设置元素2标记位mark[1]=1 调用subset，res2接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 返回res1^res2 res1接收返回值，即两个子集价值的异或和 设置元素1标记位mark[0]=1 调用subset 设置元素2标记位mark[1]=0 调用subset，res1接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 设置元素2标记位mark[1]=1 调用subset，res2接收返回值 满足pos==cnt条件，进入基础部分，计算子集价值后返回res 返回res1^res2 res2接收返回值，即两个子集价值的异或和 返回res1^res2，即4个子集价值的异或和 &emsp;&emsp;如果子集函数subset的返回类型设计为void，则需要定义一个全局变量或者在子集函数内部定义一个静态局部变量res来存储子集价值的异或和，每次求出一个子集价值后与res进行异或运算，最后在主函数中直接输出res的结果即可。但是需要注意，在C++中要尽可能少的使用全局变量，所以子集函数的返回类型设计为int更好，通过每一次的值返回可以对递归过程有更深刻的认识。 P1002:全排列问题 算法描述&emsp;&emsp;问题包括两个子问题，求全排列和序列价值。&emsp;&emsp;求全排列：将待求排列的数组分为前缀和后缀，递归部分为通过循环依次将后缀中的每个元素与后缀中的第一个元素交换作为前缀，求剩余后缀的排列，然后复原到交换前的状态。基础部分为后缀仅有一个元素，此时得到一个确定的排列。&emsp;&emsp;求序列价值：当后缀部分仅有一个元素时，此时的排列确定，通过数组名和数组长度调用价值函数，求出子集价值，返回至上一层。 C++实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;int value(T *p,int cnt) //求序列价值{ T sum=0; for(int i=0;i&lt;cnt;i++) { sum+=p[i]^(i+1); } return sum;}template &lt;class T&gt;int permutations(T* list,int k,int m,int cnt) //求所有排列价值的或{ int res=0; //基础部分 if(k==m) //仅有一个排列 { res=value(list,cnt); return res; } //递归部分 else //有多于一个的排列 { for(int i=k;i&lt;=m;i++) { swap(list[k],list[i]); //交换 res|=permutations(list,k+1,m,cnt); swap(list[k],list[i]); //复原 } return res; }}int main(){ int n,result=0; cin&gt;&gt;n; int input[n]; //输入n个非负整数 for(int i=0;i&lt;n;i++) { cin&gt;&gt;input[i]; } result=permutations(input,0,n-1,n); cout&lt;&lt;result; return 0;} 结果分析&emsp;&emsp;在求全排列的过程中，递归部分需要注意在进行后缀的每个元素与后缀的第一个元素的交换后，一定要进行复原。res的意义是在已有前缀的约束下，对后缀进行所有排列的价值的或。&emsp;&emsp;这里求全排列的函数permutations的返回类型也可以设计为void,只不过需要定义一个全局变量res，每次求出排列的价值后与res进行或运算,最后在主函数输出res的结果。这样思路上更简单，但是能不用全局变量最好还是不用。","link":"/2020/10/02/DSA/DSA_1/"},{"title":"Visual Studio Code环境配置和使用技巧","text":"&emsp;&emsp;Windows平台下vscode配置较为复杂，需要下载编译环境，添加环境变量，手动在json文件中输入编译环境的目录。Linux平台下配置较为简单，使用命令行(sudo apt-get install )安装gcc和g++，然后在文件夹下新建测试文件，点击运行和调试，在弹出的窗口中直接选择gcc或g++即可自动生成json文件，不需要任何改动。 Windows平台Step1: 下载MinGW官网下载地址: MinGW-w64 - for 32 and 64 bit Windows 不同版本区别如下： 这里建议选择x86_64-posix-sehz。下载后，解压到自己常用的软件安装路径下，这里以D盘为例。 Step2: 添加环境变量1.以windows10为例，右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量。 2.找到系统变量下的Path，点击编辑，新建，将bin目录的路径复制即可。 Step3: 配置json文件1.打开vscode，选择或新建一个空文件夹目录打开作为项目目录。2.点击“文件”按钮，再点击“新建文件夹”按钮，并重命名为”.vscode”。3.在该文件夹内，在点击“新建文件”按钮，新建launch.json，tasks.json，c_cpp_properties.json三个.json文件。文件具体内容如下：launch.json 1234567891011121314151617181920212223242526{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示 &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，这里只能为cppdbg &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加） &quot;program&quot;: &quot;${workspaceFolder}/${fileBasenameNoExtension}.exe&quot;,// 将要进行调试的程序的路径 &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可 &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，一般设置为false &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录，一般为${workspaceFolder}即代码所在目录 &quot;environment&quot;: [], &quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口，true使用控制台（小黑框），false使用内置终端 &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\gdb.exe&quot;, // miDebugger的路径，注意这里要与MinGw的路径对应 &quot;preLaunchTask&quot;: &quot;g++&quot;, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } ] } tasks.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++&quot;, //这里注意一下，见下文 &quot;command&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;-ggdb3&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-std=c++17&quot;, // 使用c++17标准 &quot;-finput-charset=UTF-8&quot;, //输入编译器文本编码 默认为UTF-8 &quot;-fexec-charset=GB18030&quot;, //输出exe文件的编码 &quot;-D _USE_MATH_DEFINES&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin&quot; }, // &quot;problemMatcher&quot;: [ //C/C++插件提供的problemMatcher，文件路径有问题，会出现找不到文件的错误 // &quot;$gcc&quot; // ] &quot;problemMatcher&quot;: { &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [ &quot;relative&quot;, &quot;\\\\&quot; ], &quot;pattern&quot;: { &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 } }, &quot;presentation&quot;: { &quot;echo&quot;: true, &quot;reveal&quot;: &quot;always&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never &quot;focus&quot;: false, &quot;panel&quot;: &quot;shared&quot; // 不同的文件的编译信息共享一个终端面板 }, } ]} c_cpp_properties.json 1234567891011121314{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;MinGW64&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;, &quot;compilerPath&quot;: &quot;D:\\\\x86_64-8.1.0-release-posix-seh-rt_v6-rev0\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}&quot; ], &quot;cppStandard&quot;: &quot;c++17&quot; } ], &quot;version&quot;: 4} 一些其他的教程可能还会有settings.json文件，非必需，而且里面往往有一些仅适用于个人的习惯设置（字体大小等），这里不再展示。传送门：具体每个配置选项的含义，可参考https://www.bilibili.com/video/BV1sW411v7VZjson文件参考来源：https://blog.csdn.net/qq_40477151/article/details/103917156 Step4: 运行和调试 launch.json文件中的 1&quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口，true使用控制台（小黑框），false使用内置终端 若使用控制台，需要在main函数return之前暂停一下，否则小黑框会一闪而过，可以使用stdlib.h库中的system(“pause”)，也可简单地使用getchar()。若使用内置终端，则会直接在内置的终端输出。 调试过程与其他IDE类似，略。 一个小小的hint: 使用freopen重定向输入输出流，可以不用每次都复制一遍输入，或者无法辨别某个数据是输入还是输出（不方便比对正确结果）。Demo: 插件推荐1.Code Runner安装后即可直接运行代码，使用内置终端。一些设置如下：Warning: 一定要将“Run In Terminal”的选项勾上，否则运行之后你找不到任何地方可以输入数据！ 2.ThemeLight: Atom one light, Night Owl Light, GitHub Light.Dark: Atom one dark, One Dark Pro, Dark+.传送门: - Visual Studio Code Light Themes - Visual Studio Code Dark Themes 3.Icon: Material Icon Theme. 4.filesize: 统计文件大小。 Linux平台真的是非常easy啊！毕竟，一个连虚拟机或者双系统都拥有的人难道还不会配vscode吗？ Update1.2021-03-27: C++17标准不支持#include&lt;bits/stdc++.h&gt;，编译时会报一长串错误，C++14标准支持，如果想使用这个头文件，可以在json文件中将C++标准改为C++14。终于解决了一个困扰已久的问题。","link":"/2021/03/20/Configuring%20Environment/vscode/"},{"title":"DSA：（二）排序","text":"&emsp;&emsp;本文讲述四种简单排序算法，名次排序、及时终止的选择排序、及时终止的冒泡排序、插入排序。 P1003:排序算法 算法描述&emsp;&emsp;定义排序类，私有成员包括指向动态数组的指针和数组的大小，公有成员包括构造函数，复制构造函数，析构函数，名次排序，及时终止的选择排序，及时终止的冒泡排序，插入排序，输入、输出函数。&emsp;&emsp;名次排序需要计算出元素在序列的名次，即所有比它小的元素个数加上左侧出现的大小相同的元素个数，然后根据元素的名次进行排序，可以使用附加数组，也可以原地重排。&emsp;&emsp;及时终止的选择排序是每次从无序段中找出最大元素，然后和无序段的末端元素进行交换，继续进行下一次排序。在寻找最大元素的过程中，如果判断出无序段已经有序，即每个元素均小于等于后面的元素，排序及时终止。&emsp;&emsp;及时终止的冒泡排序是比较两个相邻元素的大小，将较大的元素交换至后面，每次冒泡过程可将序列中最大的元素调整到末端。如果在冒泡过程中判断出未进行交换，即任意相邻的两个元素均满足前面的元素小于后面的元素，排序及时终止。&emsp;&emsp;插入排序是从序列中的第2个元素开始到第n个元素，每个元素依次作为被插入元素，在前n-1个元素构成的有序段中按照元素大小寻找合适位置进行插入。在寻找插入位置时，通过从后向前寻找，如果当前位置的元素大于被插入元素，当前位置元素后移一个位置，如果当前位置的元素小于等于被插入元素，则将被插入元素插入到当前元素的后一个位置。如果从前向后寻找插入位置，需要额外声明变量存储数据。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class SORT{private: T* pArray; //保存动态数组 int size; //数组大小public: SORT(int s); //构造函数 SORT(const SORT&lt;T&gt;&amp; S); //复制构造函数 ~SORT(); //析构函数 void rank_sort(); //名次排序 void selection_sort(); //及时终止的选择排序 void bubble_sort(); //及时终止的冒泡排序 void insert_sort(); //插入排序 void input(); //输入 void output(); //输出};template &lt;class T&gt;SORT&lt;T&gt;::SORT(int s) //构造函数{ size=s; pArray=new T[size];}template &lt;class T&gt;SORT&lt;T&gt;::SORT(const SORT&lt;T&gt;&amp; S) //复制构造函数{ size=S.size; pArray=new T[size]; for(int i=0;i&lt;size;i++) { pArray[i]=S.pArray[i]; }}template &lt;class T&gt;SORT&lt;T&gt;::~SORT() //析构函数{ delete []pArray;}template &lt;class T&gt;void SORT&lt;T&gt;::rank_sort()//附加数组的名次排序{ //计算名次 int order[size]; //保存名次的数组 for(int i=0;i&lt;size;i++) //初始化 order[i]=0; for(int i=1;i&lt;size;i++) for(int j=0;j&lt;i;j++) if(pArray[j]&lt;=pArray[i]) order[i]++; else order[j]++; T* temp=new T[size]; //附加数组 for(int i=0;i&lt;size;i++) //按照名次排序 temp[order[i]]=pArray[i]; for(int i=0;i&lt;size;i++) //复制 pArray[i]=temp[i]; delete []temp;}template &lt;class T&gt;void SORT&lt;T&gt;::selection_sort() //及时终止的选择排序{ bool sorted=false; //判断是否有序 for(int pos=size;!sorted &amp;&amp; (pos&gt;1);pos--) { int indexOfMax=0; sorted=true; //每次初始化为有序 //查找最大元素 for(int i=1;i&lt;pos;i++) { if(pArray[indexOfMax]&lt;=pArray[i]) indexOfMax=i; else sorted=false; //无序 } swap(pArray[indexOfMax],pArray[pos-1]); }}template &lt;class T&gt;void SORT&lt;T&gt;::bubble_sort() //及时终止的冒泡排序{ bool sorted=false; //判断是否有序 for(int i=0;i&lt;size-1&amp;&amp;!sorted;i++)//size个数最多进行(size-1)次冒泡 { sorted=true; //每次初始化为有序 for(int j=0;j&lt;size-1-i;j++) { if(pArray[j+1]&lt;pArray[j]) { swap(pArray[j],pArray[j+1]); sorted = false; //发生了交换,仍处于无序状态 } } }}template &lt;class T&gt;void SORT&lt;T&gt;::insert_sort() //插入排序{ for(int i=1;i&lt;size;i++) { T t=pArray[i]; //待插入的元素 int j; for(j=i-1;j&gt;=0 &amp;&amp; t&lt;pArray[j];j--) //寻找插入位置 pArray[j+1]=pArray[j]; pArray[j+1]=t; }}template &lt;class T&gt;void SORT&lt;T&gt;::input() //输入{ for(int i=0;i&lt;size;i++) cin&gt;&gt;pArray[i];}template &lt;class T&gt;void SORT&lt;T&gt;::output() //输出{ for(int i=0;i&lt;size;i++) cout&lt;&lt;pArray[i]&lt;&lt;&quot; &quot;;}int main(){ int n; cin&gt;&gt;n; SORT&lt;int&gt; s(n); //创建对象 s.input(); s.bubble_sort(); s.output(); return 0;} 结果分析（1）名次排序、冒泡排序、插入排序是稳定的，选择排序是不稳定的。e.g. 给序列3，1，1排序，首先找出最大元素3，和末端的1交换，序列变为1，1，3，满足及时终止的条件，排序结束，两个1的相对位置发生了变化。（2）在使用for循环进行次数控制时，要注意边界，防止出现数组越界或者排序次数不够的情况。（3）名次排序、冒泡排序、插入排序、选择排序的时间复杂度都是O(n^2)。（4）对于名次排序，采用附加数组和原地重排两种方式进行比较，原地重排的最坏执行时间增加了，但是内存占用减少了，用时间换空间。 Postscript1.排序的稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。2.排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。例如若将上面的冒泡排序中相邻量元素交换的判定条件改为pArray[j+1]&lt;=pArray[j],则两个相等的元素就会交换位置，从而变成不稳定的排序算法。3.上面的代码只给出了采用附加数组的名次排序，这里给出原地重排的代码实现。 123456789101112131415161718192021222324template &lt;class T&gt;void SORT&lt;T&gt;::rank_sort()//原地重排数组使之有序{ //计算名次 int order[size]; //保存名次的数组 for(int i=0;i&lt;size;i++) //初始化 order[i]=0; for(int i=1;i&lt;size;i++) for(int j=0;j&lt;i;j++) if(pArray[j]&lt;=pArray[i]) order[i]++; else order[j]++; //原地重排 for(int i=0;i&lt;size;i++) { //把正确的元素移到pArray[i] while(order[i]!=i) { int t=order[i]; swap(pArray[i],pArray[t]); swap(order[i],order[t]); } }}","link":"/2020/10/02/DSA/DSA_2/"},{"title":"DSA：（三）数组描述线性表","text":"&emsp;&emsp;经过前面两次基础知识的铺垫之后，我们正式进入数据结构部分。本文通过通讯录的实现来分析线性表的数组描述。 P1004:通讯录要求1.不要使用STL（可以使用string类）。2.封装线性表类，提供插入，删除，查找等操作。3.线性表实现使用数组描述方法（顺序存储结构）。 描述&emsp;&emsp;设通讯录中每一个联系人的内容有：姓名、电话号码、班级宿舍。由标准输入读入联系人信息，使用线性表中操作实现通讯录管理功能，包括：插入、删除、编辑、查找（按姓名查找）；键盘输入一班级，输出通讯录中该班级中所有人的信息。 格式&emsp;&emsp;每个操作的第一个数为操作数(插入：0，删除：1，编辑：2，查找：3，输出一个班所有人员信息：4)，具体格式如下： 123450 姓名 电话 班级 宿舍 //插入一条记录1 姓名 //根据姓名删除一条记录2 姓名 编辑项目 项目新值 //根据姓名编辑一条记录(编辑项目为1到3的整数，1代表编辑电话，2代表编辑班级，3代表编辑宿舍)3 姓名 //根据姓名查找，找到输出1，未找到输出04 班级 //输出该班级的所有成员的宿舍号的异或值 &emsp;&emsp;其中查找操作当找到相应的人时输出1，未找到输出0。输出一个班级的人员信息时输出所有成员的宿舍号的异或值。输入数据保证合法。 输入&emsp;&emsp;第一行一个n(1&lt;=n&lt;=20000), 代表接下来操作的数目。接下来n行代表各项操作。 输出&emsp;&emsp;当遇到查找和输出一个班所有人员信息操作时输出。 样例输入点击右上角可直接复制。 1234567891011121314151617181920212223242526272829280 Evan 57298577609 1 650 WINNIE 37367348390 4 13 Evan4 63 WINNIE1 Evan4 71 WINNIE3 MARYAM3 CAMERON3 TZIVIA0 OMAR 16447001130 6 554 84 23 JADEN3 ELIZABETH2 OMAR 1 794099055683 JOSHUA2 OMAR 1 89782148171 OMAR3 Azaan3 MARIA0 HANNAH 94060479192 5 983 HEIDY1 HANNAH0 Axel 92066832927 3 701 Axel3 TIFFANY 输出123456789101112131415161010000000000000 限制1s 算法描述&emsp;&emsp;定义结构体contact，包含姓名、电话号码、班级、宿舍信息。线性表中的每一个元素都是一个结构体，通过结构体可以访问具体的个人信息。&emsp;&emsp;使用顺序存储结构，封装线性表类AddressList，私有成员包括联系人个数contactSize，一维数组的容量listLength，存储联系人的一维数组element。公有成员包括构造函数，复制构造函数，析构函数，以及具体的方法，包括插入一条信息，根据姓名删除一条记录，根据姓名编辑电话，根据姓名编辑班级或宿舍（与根据姓名编辑电话函数形成重载），根据姓名查找，输出班级所有成员宿舍号的异或值。&emsp;&emsp;读入数据时，按行读入，首先读入操作数instruction，根据操作数利用switch分支进行分类，再根据所属操作类别读入对应的数据，调用对应的成员函数，输出数据。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdexcept&gt;using namespace std;struct contact{ string name; //姓名 string telephoneNumber; //电话号码 int classNumber; //班级 int dormitoryNumber; //宿舍};class AddressList{private: int contactSize; //联系人的个数 int listLength; //一维数组的容量 contact* element; //存储联系人的一维数组public: AddressList(int initialCapacity=10); //构造函数 AddressList(const AddressList&amp; s); //复制构造函数 ~AddressList(); //析构函数 void insert(string name, string telephoneNumber, int classNumber, int dormitoryNumber); //插入一条记录 void eraser(string name); //根据姓名删除一条记录 void edit(string name, int num, string telephoneNumber); //根据姓名编辑电话 void edit(string name, int num, int Number); //根据姓名编辑班级或宿舍 int search(string name); //根据姓名查找 int outputClass(int classNumber); //输出班级所有成员宿舍号的异或值};AddressList::AddressList(int initialCapacity) //构造函数{ if(initialCapacity&lt;1) //初始容量小于1，抛出异常 { throw invalid_argument(&quot;InitialCapacity must be positive.&quot;); } listLength=initialCapacity; element=new contact[listLength]; contactSize=0;}AddressList::AddressList(const AddressList&amp; s) //复制构造函数{ listLength=s.listLength; contactSize=s.contactSize; element=new contact[listLength]; for(int i=0;i&lt;contactSize;i++) element[i]=s.element[i];}AddressList::~AddressList() //析构函数{ delete []element;}void AddressList::insert(string name, string telephoneNumber, int classNumber, int dormitoryNumber) //插入一条记录{ if(contactSize==listLength) //数组已满，容量扩大两倍 { contact* Nelement=new contact[listLength*2]; listLength=listLength*2; for(int i=0;i&lt;contactSize;i++) { Nelement[i]=element[i]; } delete []element; element=Nelement; } //在线性表末端(下标为contactSize处)插入一条记录 element[contactSize].name=name; element[contactSize].telephoneNumber=telephoneNumber; element[contactSize].classNumber=classNumber; element[contactSize].dormitoryNumber=dormitoryNumber; contactSize++;}void AddressList::eraser(string name) //根据姓名删除一条记录{ int index=0; //姓名对应的索引 for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) index=i; } for(int i=index+1;i&lt;contactSize;i++) //向左移动元素 { element[i-1]=element[i]; } element[--contactSize].~contact(); //联系人个数-1,析构无效元素}void AddressList::edit(string name, int num, string telephoneNumber) //根据姓名编辑电话{ for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) { element[i].telephoneNumber=telephoneNumber; } }}void AddressList::edit(string name, int num, int Number) //根据姓名编辑班级或宿舍{ if(num==2) //编辑班级 { for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) { element[i].classNumber=Number; } } } else //编辑宿舍 { for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) { element[i].dormitoryNumber=Number; } } }}int AddressList::search(string name) //根据姓名查找{ for(int i=0;i&lt;contactSize;i++) { if(element[i].name==name) return 1; } return 0;}int AddressList::outputClass(int classNumber) //输出班级所有成员宿舍号的异或值{ int res=0; for(int i=0;i&lt;contactSize;i++) { if(element[i].classNumber==classNumber) { res^=element[i].dormitoryNumber; } } return res;}int main(){ int n;//操作数目 cin&gt;&gt;n; AddressList Contact(10); //创建联系人对象 int instruction; //指令编号 string iName,iTelephone; //读入的姓名、电话信息 int iClass,iDormitory; //读入的班级、宿舍信息 for(int i=0;i&lt;n;i++) { cin&gt;&gt;instruction; switch(instruction) { case 0: //插入一条记录 cin&gt;&gt;iName&gt;&gt;iTelephone&gt;&gt;iClass&gt;&gt;iDormitory; Contact.insert(iName,iTelephone,iClass,iDormitory); break; case 1: //删除一条记录 cin&gt;&gt;iName; Contact.eraser(iName); break; case 2: //根据姓名编辑一条记录 int editNum; cin&gt;&gt;iName&gt;&gt;editNum; if(editNum==1) { cin&gt;&gt;iTelephone; Contact.edit(iName,editNum,iTelephone); } else if (editNum==2) { cin&gt;&gt;iClass; Contact.edit(iName,editNum,iClass); } else { cin&gt;&gt;iDormitory; Contact.edit(iName,editNum,iDormitory); } break; case 3: //根据姓名查找 cin&gt;&gt;iName; cout&lt;&lt;Contact.search(iName)&lt;&lt;endl; break; case 4: //输出班级所有成员宿舍号的异或 cin&gt;&gt;iClass; cout&lt;&lt;Contact.outputClass(iClass)&lt;&lt;endl; break; } } return 0;} 结果分析&emsp;&emsp;第一次提交时7个节点通过，3个节点RE，一直找不到错误，然后仔细读代码(大概也就读了十几遍的样子)，发现在成员函数insert中，新数组动态申请时使用listLength*2表示新数组的元素个数，之后忘了对listLength扩大两倍（我真是个憨憨），修改后提交通过。","link":"/2020/10/04/DSA/DSA_3/"},{"title":"DSA：（七）队列","text":"&emsp;&emsp;循环队列的数组描述有不同的实现策略，主要不同之处在于如何区分队列是空还是满。本文的实现策略是不将队列插满，队列元素个数最多是arrayLength-1，在向队列插入元素之前，先要判断本次操作是否会使队列变满。 P1011:卡片游戏描述假设桌上有一叠扑克牌，依次编号为1-n（从上至下）。当至少还有两张的时候，可以进行操作：把第一张牌扔掉，然后把新的第一张（原先扔掉的牌下方的那张牌,即第二张牌）放到整叠牌的最后。输入n，输出最后剩下的牌。 要求1.创建队列类，使用数组描述的循环队列。2.实现卡片游戏。 格式输入一个整数n，代表一开始卡片的总数。 输出最后一张卡片的值。 样例输入1100 输出172 限制1s, 64MB for each test case. 算法描述&emsp;&emsp;使用数组存储结构，封装循环队列类arrayQueue，私有成员包括队列首元素的下一个位置（逆时针）queueFront，队列尾元素的位置queueBack，数组大小arrayLength，存储队列的数组queue。公有成员包括构造函数，析构函数，ADT方法包括判断队列是否为空，返回队列中元素个数，返回队首元素，返回队尾元素，删除队首元素，将元素插入到队尾。&emsp;&emsp;构造函数中，设置queueFront=queueBack=0。队空标志为queueFront=queueBack，队列元素个数为(arrayLength+queueBack-queueFront)%arrayLength。元素入队时，若插入一个元素后队列满，需要扩大容量，通过queueFront计算队列首元素的位置start，与2进行比较判断原队列中是否形成环，若没有形成环，对元素只需调用一次copy方法进行复制，若形成环，需要使用copy进行两次复制。&emsp;&emsp;对扑克牌进行操作，把第一张牌扔掉，队列操作是删除队首元素；把新的一张牌放到整叠牌的最后，队列操作是获得队首元素，删除队首元素，将得到的队首元素插入到队尾。通过队列的元素个数进行循环控制。 C++实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}int main(){ int n; cin&gt;&gt;n; arrayQueue&lt;int&gt; card; for(int i=1;i&lt;=n;i++) card.push(i); while(card.size()&gt;=2) { card.pop(); int t=card.front(); card.pop(); card.push(t); } cout&lt;&lt;card.front()&lt;&lt;endl; return 0;} 结果分析1.构造函数设置queueFront=queueBack=0，保证符合队列为空的标志，并且将0号位置空出来，从1号位置开始插入。队列的最大元素个数为arrayLength-1，若插入一个元素后队列满，可以根据队列首元素的位置与2的大小关系判断队列中是否形成了环，然后进行元素的复制。2.通过queueFront和queueBack计算队列元素个数，若队列中没有形成环，queueBack-queueFront得到队列元素个数，若队列中形成了环，queueFront-queueBack为空白位置的个数，arrayLength-(queueFront-queueBack)得到队列元素个数。将两种情况合并，(arrayLength+queueBack-queueFront)%arrayLength表示队列元素个数。","link":"/2020/11/12/DSA/DSA_7/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Hello HexoQuick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/10/02/Hello%20World/hello-world/"},{"title":"程序设计思维与实践：Week1","text":"&emsp;&emsp;Week1作业和实验 作业A：打酱油问题描述小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式输出一个整数，表示小明最多可以得到多少瓶酱油。 样例1输入140 输出15 样例说明把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。 样例2输入180 输出111 样例说明把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,cnt=0; scanf(&quot;%d&quot;,&amp;n); while(n&gt;=50) { cnt+=7; n-=50; } while(n&gt;=30) { cnt+=4; n-=30; } while(n&gt;=10) { cnt++; n-=10; } printf(&quot;%d\\n&quot;,cnt); return 0;} B：最小差值问题描述给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。 输入格式输入第一行包含一个整数n。第二行包含n个正整数，相邻整数之间使用一个空格分隔。 输出格式输出一个整数，表示答案。 样例1输入1251 5 4 8 20 输出11 样例说明相差最小的两个数是5和4，它们之间的差值是1。 样例2输入1259 3 6 1 3 输出10 样例说明有两个相同的数3，它们之间的差值是0。 数据规模和约定对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std; int num[1000]; int main(){ int n,min; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;num[i]); } min=fabs(num[0]-num[1]); for(int i=0;i&lt;n-1;i++) { for(int j=i+1;j&lt;n;j++) { if(fabs(num[i]-num[j])&lt;fabs(min)) min=fabs(num[i]-num[j]); } } printf(&quot;%d\\n&quot;,min); return 0;} 实验A：签到题【请在实验开始5分钟内完成签到】Description请在比赛开始 5分钟 以内提交以下代码进行签到。 12#include &lt;cstdio&gt;int main(){puts(&quot;qiandao&quot;);} B：IO1Description计算a+b。 Input输入第一行是一个整数N，代表接下来N行会有N组样例输入。 Output每组输出占一行。 Sample Input12321 510 20 Sample Output12630 Code1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,a,b; scanf(&quot;%d&quot;,&amp;n); while(n--) { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,a+b); } return 0; C：IO2Description计算a+b。 Input有多组样例输入，以0 0代表输入结束。 Output每组输出占一行。 Sample Input1231 510 200 0 Sample Output12630 Code12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,a,b; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b) &amp;&amp; a!=0 &amp;&amp; b!=0) { printf(&quot;%d\\n&quot;,a+b); } return 0;} D：IO3Description计算a+b。 Input有多组样例输入。 Output每组输出占一行。 Sample Input121 510 20 Sample Output12630 Code12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,a,b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) { printf(&quot;%d\\n&quot;,a+b); } return 0;} E：IO4问题描述你的任务是计算一些整数的和。 输入格式输入包含多组样例。每组样例包含一个整数N，然后在同行有N个整数。若N = 0，则表示输入结束，这个样例不需要被处理。 输出格式对于每组用例，你应当输出这组样例N个数字的和，每个输出占一行。 样例输入1234 1 2 3 45 1 2 3 4 50 样例输出121015 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; while(scanf(&quot;%d&quot;,&amp;n) &amp;&amp; n!=0) { int x,sum=0; for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;x); sum+=x; } printf(&quot;%d\\n&quot;,sum); } return 0;} F：IO5问题描述请计算下面每行数的和。 输入格式第一行有一个整数N，表示有N行数。接下来N行，每行第一个为整数M，表示本行后面有M个整数。 输出格式对于输入的每一行数，请分别对应输出每一行数的和。 样例输入12324 1 2 3 45 1 2 3 4 5 样例输出121015 Hint本题相关知识：输入输出和循环语句（for）的使用方式。 Code1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { int m,x,sum=0; scanf(&quot;%d&quot;,&amp;m); for(int i=0;i&lt;m;i++) { scanf(&quot;%d&quot;,&amp;x); sum+=x; } printf(&quot;%d\\n&quot;,sum); } return 0;} G：IO6问题描述请计算下面每行数的和。 输入格式输入包含多组数据，每组数据占一行。每行第一个数为整数N，后面有N个整数。 输出格式对于输入的每一行数，请分别对应输出每一行数的和。 样例输入124 1 2 3 45 1 2 3 4 5 样例输出121015 Hint本题相关知识：输入输出和循环语句（while）的使用方式。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int m; while(~scanf(&quot;%d&quot;,&amp;m)) { int x,sum=0; for(int i=0;i&lt;m;i++) { scanf(&quot;%d&quot;,&amp;x); sum+=x; } printf(&quot;%d\\n&quot;,sum); } return 0;} H：IO7问题描述请计算下面每行数的和。 输入格式输入包含多组数据，每组数据占一行。每行有若干个整数。 输出格式对于输入的每一行数，请分别对应输出每一行数的和。 样例输入121 2 3 41 2 3 4 5 样例输出121015 Hint本题相关知识：读取一行的处理和格式化读取字符串，也可使用getline和stringstream。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std; int main(){ string a; while(getline(cin,a)) { istringstream is(a); int sum=0; int x; while(is&gt;&gt;x) sum+=x; cout&lt;&lt;sum&lt;&lt;endl; } return 0;} I：IO8问题描述给定两个十六进制整数a和b，输出他们的和。 输入格式输入多组数据，以EOF作为数据的结束。每组数据在一行中包含了两个十六进制整数a和b。 输出格式对于每一组数据，以十进制输出a+b的和。每组输出占用一行。 样例输入1231 9A Ba b 样例输出123102121 Code1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int a,b; while(~scanf(&quot;%x%x&quot;,&amp;a,&amp;b)) printf(&quot;%d\\n&quot;,a+b); return 0;} J：Discount问题描述给出商品的原价和现价，求该商品的优惠力度。 输入格式输入两个数 A,B(1≤B&lt;A≤10^5)，分别表示原价和现价。 输出格式输出一个实数，表示降价的百分比，保留三位小数输出。 样例输入17 5 样例输出128.571 Code1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int a,b; double x; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); x=100.0*(a-b)/a; printf(&quot;%.3f\\n&quot;,x); return 0;} K：Slot问题描述给出一个长度为3的字符串，所有字母均为大写英文字母，请判断该字符串是否由同一个字母构成。 输入格式输入一行表示字符串。 输出格式若该字符串是否由同一个字母构成，输出Won，否则输出Lost。 样例输入11TTT 样例输出11Won 样例输入21SYS 样例输出21Lost Code12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ char str[3]; scanf(&quot;%s&quot;,str); if(str[0]==str[1] &amp;&amp; str[1]==str[2]) printf(&quot;Won\\n&quot;); else printf(&quot;Lost\\n&quot;); return 0;} L：Orthogonality 样例输入112331 0 5-5 0 1 样例输出11Yes 样例输入212331 2 33 2 1 样例输出21No Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;int a[100000],b[100000];int main(){ int n,res=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;b[i]); } for(int i=0;i&lt;n;i++) { res+=a[i]*b[i]; } if(res==0) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); return 0;} M：uNrEaDaBlE sTrInG问题描述我们称一个字符串是“难读的”，当且仅当它的奇数位置的字母都是小写字母，偶数位置的字母都是大写字母。请你判断一个字符串是否为“难读的”字符串。 输入格式输入一行包含一个字符串。 输出格式如果输入的字符串是“难读的”，输出Yes，否则输出No。 样例输入11tImElImItExCeEdEd 样例输出11Yes 样例输入21AccePt 样例输出21No Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ string str; cin&gt;&gt;str; for(int i=0;i&lt;str.size();i++) { if(i%2==0) { if(str.at(i)&gt;='a' &amp;&amp; str.at(i)&lt;='z') continue; else {printf(&quot;No\\n&quot;); return 0;} } else { if(str.at(i)&gt;='A' &amp;&amp; str.at(i)&lt;='Z') continue; else {printf(&quot;No\\n&quot;); return 0;} } } printf(&quot;Yes\\n&quot;); return 0;} N：Remove It问题描述给出一个长度为n的数列和一个数x，请从数列中删除数值等于x的项，输出剩余的数列。 输入格式输入第一行包含两个整数n,x，第二行包含n个整数，表示数列。 输出格式输出一行，表示删除后的数列。输出数字的相对顺序应与原数列相同。 样例输入1126 41 2 3 4 3 4 样例输出111 2 3 3 样例输入2123 66 6 6 样例输出21 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,x,a; scanf(&quot;%d%d&quot;,&amp;n,&amp;x); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a); if(a!=x) printf(&quot;%d &quot;,a); else continue; } return 0;} O：Rally 样例输入1265 2 4 2 8 8 样例输出137 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int pos[100];int main(){ int n,a,b; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;pos[i]); a=pos[0]; b=pos[0]; for(int i=1;i&lt;n;i++) { if(pos[i]&lt;a) a=pos[i]; if(pos[i]&gt;b) b=pos[i]; } int res=0; for(int j=0;j&lt;n;j++) res+=(pos[j]-a)*(pos[j]-a); for(int i=a+1;i&lt;=b;i++) { int cur=0; for(int j=0;j&lt;n;j++) { cur+=(pos[j]-i)*(pos[j]-i); } if(cur&lt;res) res=cur; } printf(&quot;%d\\n&quot;,res); return 0;} P：：(Colon)问题描述钟表的时针和分针长度分别为a,b，当前的时间为H时M分，求时针端点与分针端点的距离。 输入格式输入一行包含4个整数a,b,H,M。 输出格式输出一个实数，表示端点之间的距离。你的输出与实际值的误差应小于10^(-9)。 样例输入13 4 10 40 样例输出14.56425719433005567605 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;#define pi 3.1415926535int main(){ int a,b,H,M; double j,x; scanf(&quot;%d%d%d%d&quot;,&amp;a,&amp;b,&amp;H,&amp;M); j=fabs(H*30+M*0.5-M*6); x=sqrt(a*a+b*b-2*a*b*cos(j*pi/180)); printf(&quot;%.9f\\n&quot;,x); return 0;} Q：Kaprekar Number 样例输入111024 2 样例输出118172 样例输入2110 3 样例输出210 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;int g1(int x){ if(x==0) return 0; int a[20],w,y=0; for(int i=0;x&gt;0;i++) { a[i]=x%10; x=x/10; w=i; } w++; for(int i=0;i&lt;w-1;i++) { for(int j=0;j&lt;w-i-1;j++) { if(a[j]&lt;a[j+1]) { swap(a[j],a[j+1]); } } } for(int i=0;i&lt;w;i++) { y+=a[i]*pow(10,w-i-1); } return y;}int g2(int x){ if(x==0) return 0; int a[20],w,y=0; for(int i=0;x&gt;0;i++) { a[i]=x%10; x=x/10; w=i; } w++; for(int i=0;i&lt;w-1;i++) { for(int j=0;j&lt;w-i-1;j++) { if(a[j]&gt;a[j+1]) { swap(a[j],a[j+1]); } } } for(int i=0;i&lt;w;i++) { y+=a[i]*pow(10,w-i-1); } return y;}int main(){ int N,K,res=0; scanf(&quot;%d%d&quot;,&amp;N,&amp;K); for(int i=0;i&lt;K;i++) { res=g1(N)-g2(N); N=res; } printf(&quot;%d\\n&quot;,res); return 0;}","link":"/2021/03/21/Programming%20Thinking%20and%20Practice/week-1/"},{"title":"程序设计思维与实践：Week2","text":"&emsp;&emsp;Week2作业 A：相邻数对问题描述给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 输入格式输入的第一行包含一个整数n，表示给定整数的个数。第二行包含所给定的n个整数。 输出格式输出一个整数，表示值正好相差1的数对的个数。 样例输入12610 2 6 3 7 8 样例输出13 样例说明值正好相差11的数对包括 (2, 3), (6, 7), (7, 8)。 评测用例规模与约定1≤n≤1000，给定的整数为不超过 1000010000 的非负整数。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,cnt=0,temp; cin&gt;&gt;n; vector&lt;int&gt; x(n); while(n--) { cin&gt;&gt;temp; x.push_back(temp); } for(auto it=x.begin();it!=x.end();it++) { for(auto ib=it+1;ib!=x.end();ib++) { if((*ib)-(*it)==1 || (*ib)-(*it)==-1) cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; return 0;} B：门禁系统问题描述涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。 输入格式输入的第一行包含一个整数n，表示涛涛的记录条数。第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。 输出格式输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。 样例输入1251 2 1 1 3 样例输出11 1 2 3 1 评测用例规模与约定1≤n≤1000，读者的编号为不超过n的正整数。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,temp; cin&gt;&gt;n; map&lt;int,int&gt; x; while(n--) { cin&gt;&gt;temp; x[temp]++; cout&lt;&lt;x[temp]&lt;&lt;&quot; &quot;; } return 0;} C：桶装数字问题描述yhf有n个桶，每个桶里都装着一些数字（一个或多个），所有的数字总共有m个。这天，lzh把yhf所有的桶全打翻了，数字洒了一地！所幸，每个数字都有它所在的桶的标记。yhf希望恢复所有的桶，但是他还要刷考研题目，于是他拜托你来完成这个任务。由于yhf能在一秒内完成一套考研数学题，因此他希望你的程序能在一秒内得出结果。 输入格式第一行输入两个整数n,m，第二行到第m+1行，每行两个整数x,t，分别表示这个数字和它所在的桶。保证每个桶至少含有一个数字。 输出格式输出n行，若第i个桶含有k_i个数字，则第i行输出k_i个整数，表示这个桶内的数字。注意：输出每个桶的数字时应按升序排序输出。 样例输入1234562 53 12 22 13 21 2 样例输出122 31 2 3 评测用例规模与约定 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m,a,b; cin&gt;&gt;n&gt;&gt;m; vector&lt;vector&lt;int&gt;&gt; x(n+1,vector&lt;int&gt;()); while(m--) { cin&gt;&gt;a&gt;&gt;b; x[b].push_back(a); } for(int i=1;i&lt;=n;i++) sort(x[i].begin(),x[i].end()); for(int i=1;i&lt;=n;i++) { for(auto k:x[i]) cout&lt;&lt;k&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } return 0;} D：笔记本问题描述为了复习考研英语，yhf开始背单词。yhf有一个笔记本，一开始是空的。当yhf遇到一个不认识的单词时，他会先查找笔记本，如果笔记本上没有，他就会先在互联网上查找这个单词，然后记在笔记本上。当yhf认为他已经熟记一个单词时，他会将这个单词在笔记本上擦掉（如果笔记本上没有就不用擦了）。yhf有时也会关心他的笔记本上记了多少单词，他会将笔记本上的单词按照字典序升序读一遍。这天，yhf发现他的笔记本已经记满了单词，他决定用程序来实现笔记本的功能。但考虑到编写程序消耗的时间可以多背几千个单词，他决定把这个任务交给你。 输入格式输入第一行包含一个整数m，接下来有m行，每一行有一个整数op，表示你的程序应执行哪种操作,具体如下： op=1，后接一个单词，表示查找这个单词；如果笔记本中没有这个单词，则将单词写进笔记本。 op=2，后接一个单词，表示删除这个单词；如果笔记本中没有这个单词，则无需进行操作。 op=3，表示按字典序通读整个笔记本。 输出格式输出m行，每一行表示输入的操作对应的输出，具体如下： op=1，如果笔记本中有这个单词，输出found，否则输出write。 op=2，如果笔记本中有这个单词，输出erased，否则输出not found。 op=3，在一行内按字典序升序输出所有单词，中间用空格隔开。 样例输入12345678981 problem1 problem2 problem1 problem2 acm1 pro1 acm3 样例输出12345678writefounderasedwritenot foundwritewriteacm pro problem 评测用例规模与约定 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int m,op; string s; map&lt;string,bool&gt; note; cin&gt;&gt;m; while(m--) { cin&gt;&gt;op; if(op==1) { cin&gt;&gt;s; auto it=note.find(s); if(it!=note.end()) cout&lt;&lt;&quot;found&quot;&lt;&lt;endl; else { note.insert(make_pair(s,true)); cout&lt;&lt;&quot;write&quot;&lt;&lt;endl; } } else if(op==2) { cin&gt;&gt;s; auto it=note.find(s); if(it!=note.end()) { note.erase(it); cout&lt;&lt;&quot;erased&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;not found&quot;&lt;&lt;endl; } } else { for(auto &amp;x:note) cout&lt;&lt;x.first&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } return 0;}","link":"/2021/03/21/Programming%20Thinking%20and%20Practice/week-2/"},{"title":"程序设计思维与实践：Week3","text":"&emsp;&emsp;Week3作业和CSP模测（一） 作业A：游戏问题描述有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式输入一行，包括两个整数n和k，意义如题目所述。 输出格式输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入115 2 样例输出113 样例输入217 3 样例输出214 数据规模和约定对于所有评测用例，1≤n≤1000，1≤k≤9。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,k,num=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); queue&lt;int&gt; q; for(int i=1;i&lt;=n;i++) q.push(i); while(q.size()&gt;1) { num++; if(num%k==0 || num%10==k) { q.pop(); } else { q.push(q.front()); q.pop(); } } printf(&quot;%d\\n&quot;,q.front()); return 0;} B：跳一跳问题描述近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。 简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。 如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。 现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入11 1 2 2 2 1 1 2 2 0 样例输出122 数据规模和约定对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int x,sum=0,last=0,i=0; while(~scanf(&quot;%d&quot;,&amp;x) &amp;&amp; x!=0) { i++; if(i==1) //first jump { if(x==1) {sum+=1; last=1;} else {sum+=2; last=2;} } else { if(x==1) { sum+=1; last=1; } if(x==2) { if(last==1) { sum+=2; last=2; } else { sum+=last+2; last+=2; } } } } printf(&quot;%d\\n&quot;,sum); return 0;} C：奇怪的电梯 样例输入1235 1 53 3 1 2 50 样例输出13 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;int k[210],vis[210],cnt[210];int main(){ int N,A,B; while(scanf(&quot;%d&quot;,&amp;N) &amp;&amp; N!=0) { scanf(&quot;%d%d&quot;,&amp;A,&amp;B); memset(k,0,210*sizeof(int)); memset(vis,0,210*sizeof(int)); memset(cnt,0,210*sizeof(int)); for(int i=1;i&lt;=N;i++) scanf(&quot;%d&quot;,&amp;k[i]); queue&lt;int&gt; q; q.push(A); vis[A]=1; cnt[A]=0; while (!q.empty()) { int r=q.front(); if(r==B) { printf(&quot;%d\\n&quot;,cnt[r]); break; } q.pop(); int up=r+k[r]; int down=r-k[r]; if(up&lt;=N &amp;&amp; vis[up]==0) { q.push(up); vis[up]=1; cnt[up]=cnt[r]+1; } if(down&gt;=1 &amp;&amp; vis[down]==0) { q.push(down); vis[down]=1; cnt[down]=cnt[r]+1; } } if(q.empty()) printf(&quot;-1\\n&quot;); } return 0;} D：选数 样例输入124 33 7 12 19 样例输出11 数据规模和约定 提示素数的判定方法 12345678bool prime(int n){ if（n==1) return false; if (n==2) return true; for(int i=2;i*i&lt;=n;i++) if (n%i==0) return false; return true; } Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int a[21];int n,k,cnt=0;bool prime(int n){ if(n==1) return false; if(n==2) return true; for(int i=2;i*i&lt;=n;i++) if(n%i==0) return false; return true;}void dfs(int sum,int kk,int x){ if(kk==k &amp;&amp; prime(sum)) { cnt++; return ; } if(x&gt;n) return ; dfs(sum,kk,x+1); dfs(sum+a[x],kk+1,x+1);}int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(0,0,1); printf(&quot;%d\\n&quot;,cnt); return 0;} E：棋盘问题问题描述小H收集到一些形状特殊的棋盘，她想在棋盘上面摆放棋子（棋子都是相同的）。她希望摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，你能帮她求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案数C嘛？ 输入格式输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n * n的矩阵内描述棋盘，以及摆放棋子的数目。当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。注意只有#棋盘区域可以摆放棋子。 输出格式对于每一组数据，给出一行输出，输出摆放的方案数目C（数据保证C&lt;2^31）。 样例输入1234567892 1#..#4 4...#..#..#..#...-1 -1 样例输出1221 数据规模和约定1&lt;=k&lt;=n&lt;=8 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;char a[10][10];int cnt = 0, n, k, kk;int vis[10];void dfs(int x){ if (kk == k) { cnt++; return; } if (x &gt;= n) return; for (int i = 0; i &lt; n; i++) { if (!vis[i] &amp;&amp; a[i][x] == '#') { vis[i] = 1; kk++; dfs(x + 1); vis[i] = 0; kk--; } } dfs(x + 1);}int main() { while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; n != -1 &amp;&amp; k != -1) { cnt = 0; kk = 0; memset(a, '\\0', 100 * sizeof(char)); memset(vis, 0, 10 * sizeof(int)); getchar(); for (int i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, a[i]); dfs(0); printf(&quot;%d\\n&quot;, cnt); } return 0;} CSP模测（一）A：R!!G!!B!!问题描述msy 的显示器被 yhf 借走了，于是 msy 需要一个新的显示器。他买来了许多 LED 小灯，每个小灯只能发出红、绿、蓝三种颜色光的其中一种。msy 需要三个不同颜色的小灯来拼成一个像素（像素之间并不能共用小灯），但是他并不知道每种颜色的小灯具体有多少个，只知道每个小灯的颜色。msy 想知道他用手头上的小灯可以拼出多少个像素，但是一个个数太麻烦了，他希望你来用程序解决这个问题。 输入格式第一行输入一个数 nn，表示所有小灯的数量。第二行输入一个长度为 nn 的字符串，表示每个小灯的颜色。颜色使用R、G、B三种字母表示。 输出格式输出一个整数，表示 msy 可以拼出的像素的个数。 样例输入128RGBRGBRG 样例输出12 评测用例规模与约定1≤n≤10^5 Code123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; scanf(&quot;%d&quot;,&amp;n); string str; cin&gt;&gt;str; int R=0,G=0,B=0; for(int i=0;i&lt;str.size();i++) { if(str[i]=='R') R++; else if(str[i]=='G') G++; else B++; } printf(&quot;%d\\n&quot;,min(min(R,G),B)); return 0;} B：密码强弱度问题描述在很多的交互式网站中，都需要通过使用用户名与密码进行登录，为了正确的评估一个密码的强弱，机智的 lzh 想出了一个评价方案。这里研究的密码只有数字与大小写字母组成。具体的评价方案如下：如果一个密码的长度小于 66，则这个密码的强度为 00。对于长度大于等于 66 的密码，根据字符的种类（字符分为三类：数字，小写字母，大写字母），将连续的同种类的密码划分为一段，其段数即为密码的强弱程度。例如，密码 asd123As2d 可以分为 asd、123、A、s、2、d 6段，所以这个密码的强度为6。 输入格式输入一行一个字符串s，1≤∣s∣≤10^6，表示密码。 输出格式输出一行一个整数，表示密码的强弱程度。 Case 1Input11VIpuVNOv8 Output16 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;bool f(char a,char b){ if(a&gt;='a' &amp;&amp; a&lt;='z' &amp;&amp; b&gt;='a' &amp;&amp; b&lt;='z') return true; if(a&gt;='A' &amp;&amp; a&lt;='Z' &amp;&amp; b&gt;='A' &amp;&amp; b&lt;='Z') return true; if(a&gt;='0' &amp;&amp; a&lt;='9' &amp;&amp; b&gt;='0' &amp;&amp; b&lt;='9') return true; return false;}int main(){ string s; int ans=0; cin&gt;&gt;s; if(s.size()&lt;6) ans=0; else { for(int i=0;i&lt;s.size()-1;i++) { if(f(s[i],s[i+1])) { continue; } ans++; } } if(ans==0) printf(&quot;0\\n&quot;); else printf(&quot;%d\\n&quot;,ans+1); return 0;} C：拉面馆 Case 1Input123451 1 1321 1601 1 Output128 Case 2Input123456789102 5 243 452 1 22 1 251 63 66 69 732 1 21 12 1 22 1 22 1 2 Output12345620AngryAngryAngry Case 3Input1234567891011121314151617181920212223242526272829303114 14 33 4 12 15 23 26 28 30 33 34 37 41 43 451 11 22 1 32 1 32 1 22 1 21 12 1 32 1 22 1 33 1 2 31 32 1 31 259 61 62 63 66 72 80 83 88 91 92 95 96 991 21 12 1 32 1 31 21 33 1 2 32 1 32 1 32 1 22 1 31 32 1 21 1 Output1234567891011121314141825293331Angry53736580Angry7371 CodScore:30123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,k;int t[200010];int inc[200010][5];int s[200010];int lov[200010][5];int choose[200010];bool eat(int a){ int i=n; for(;i&gt;=1;i--) { if(inc[i][0]&gt;=lov[a][0] &amp;&amp; choose[i]) { int j=1; for(;j&lt;=k;j++) { if(lov[a][j]==1) { if(inc[i][j]==1) continue; else break; } } if(j&gt;k) { choose[i]=0; printf(&quot;%d\\n&quot;,s[a]-t[i]); return true; } } } if(i==0) return false; else return true;}int main(){ //freopen(&quot;a.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;a.out&quot;,&quot;w&quot;,stdout); memset(choose,1,200010*sizeof(int)); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;t[i]); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;inc[i][0]); int temp; for(int j=1;j&lt;=inc[i][0];j++) { scanf(&quot;%d&quot;,&amp;temp); inc[i][temp]=1; } /* printf(&quot;第%d碗面的配料有: &quot;,i); for(int j=1;j&lt;=k;j++) if(inc[i][j]==1) printf(&quot;%d &quot;,j); printf(&quot;\\n&quot;); */ } for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;s[i]); for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;lov[i][0]); int temp; for(int j=1;j&lt;=lov[i][0];j++) { scanf(&quot;%d&quot;,&amp;temp); lov[i][temp]=1; } /* printf(&quot;第%d个人like的配料有: &quot;,i); for(int j=1;j&lt;=k;j++) if(lov[i][j]==1) printf(&quot;%d &quot;,j); printf(&quot;\\n&quot;); */ } for(int i=1;i&lt;=m;i++) { if(eat(i)) { ; } else { printf(&quot;Angry\\n&quot;); } } return 0;} Score:100123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int t[200010], s[200010];set&lt;int&gt; sp[8];int main() { int n, m, k; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;t[i]); for (int i = 1; i &lt;= n; i++) { int kk, v = 0; scanf(&quot;%d&quot;, &amp;kk); for (int j = 1; j &lt;= kk; j++) { int x; scanf(&quot;%d&quot;, &amp;x); v |= (1 &lt;&lt; (x - 1)); } for (int j = 1; j &lt; 8; j++) if ((v &amp; j) == j) sp[j].emplace(t[i]); } for (int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, &amp;s[i]); for (int i = 1; i &lt;= m; i++) { int kk, v = 0; scanf(&quot;%d&quot;, &amp;kk); for (int j = 1; j &lt;= kk; j++) { int x; scanf(&quot;%d&quot;, &amp;x); v |= (1 &lt;&lt; (x - 1)); } if (sp[v].empty()) printf(&quot;Angry\\n&quot;); else { int tt = *sp[v].rbegin(); printf(&quot;%d\\n&quot;, s[i] - tt); for (int j = 1; j &lt; 8; j++) { sp[j].erase(tt); } } } return 0;}","link":"/2021/03/21/Programming%20Thinking%20and%20Practice/week-3/"},{"title":"DSA：（十）堆及其应用","text":"&emsp;&emsp;优先级队列中，每个元素都有一个优先级。在最小优先级队列中，查找和删除的元素都是优先级最小的元素。在最大优先级队列中，查找和删除的元素都是优先级最大的元素。优先级队列性能较好的是堆结构，一个大根堆（小根堆）既是大根树（小根树），也是完全二叉树。删除和插入的时间复杂度均为O(logn)，初始化的时间复杂度为O(n)。利用堆结构实现堆排序，时间复杂度为O(nlogn)。利用堆和二叉树，实现Huffman编码，保证没有一个编码是另一个编码的前缀，并且WEP最小。 P1016:堆的操作内容创建最小堆类，最小堆的存储结构使用数组。提供操作:插入、删除、初始化。题目第一个操作是建堆操作，接下来是对堆的插入和删除操作，插入和删除都在建好的堆上操作。 格式输入第一行一个数n（n&lt;=5000)，代表堆的大小。第二行n个数，代表堆的各个元素。第三行一个数m (m&lt;=1000)，代表接下来共m个操作。接下来m行，分别代表各个操作。下面是各个操作的格式： 插入操作：1 num 删除操作：2 排序操作：第一行两个数3和n，3代表是排序操作，n代表待排序的数的数目，接下来一行n个数是待排序数。保证排序操作只出现一次且一定是最后一个操作。 输出第一行建堆操作输出建好堆后堆顶的元素。接下来m个操作，若是插入和删除操作，每行输出执行操作后堆顶的元素的值；若是排序操作，输出一行按升序排序好的结果，每个元素间用空格分隔。 样例输入123456789101112131410-225580 113195 -257251 384948 -83524 331745 179545 293165 125998 376875101 -2325021 -3598331 951232221 2239711 -1187351 -2788433 10-96567 37188 -142422 166589 -169599 245575 -369710 423015 -243107 -108789 输出1234567891011-257251-257251-359833-359833-257251-232502-225580-225580-225580-278843-369710 -243107 -169599 -142422 -108789 -96567 37188 166589 245575 423015 Limitation1s, 64MB for each test case. 算法描述&emsp;&emsp;使用数组存储结构，封装小根堆类minHeap，私有成员包括存储堆的数组heap，数组大小arrayLength，小根堆的大小heapSize，公有成员包括构造函数，析构函数，empty方法，size方法，返回堆顶元素的top方法，向堆中插入一个元素的push方法，删除堆顶元素的pop方法，初始化一个小根堆的initialize方法，从堆的析构函数中保存数组的deactiveArray方法。定义模板函数heapSort，利用堆排序对数组进行排序。 top：返回堆顶元素。直接返回heap[1]即可。 pop：删除堆顶元素。首先将堆顶元素heap[1]删除，然后将堆的最后一个元素放在根的位置，依次和左右孩子中较小的进行比较，寻找合适的位置放入。 push：向堆中插入一个元素。首先判断数组容量是否足够，若数组已满，需要进行扩容。为插入的元素寻找插入位置，判断条件是是否到达根节点和theElement值是否小于当前位置的元素值（保证小根堆的结构）。 initialize：初始化一个小根堆。令heap指向数组theHeap，heapSize=theSize。然后从最后一个具有孩子的节点开始扫描，用root表示正在处理的节点，对于每一个root值，利用while循环将以root为根的子树调整为小根堆。 deactiveArray：从堆的析构函数中保存数组。将类的heap指针置空。 heapSort：利用堆排序对数组a[1:n]排序。首先声明一个minHeap类的对象heap，调用initialize方法初始化小根堆，然后每次删除堆顶元素，将其放在数组的最后，最后调用deactivateArray方法，将heap的指针置空，保存数组a。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class minHeap //小根堆{private: T *heap; //保存堆的数组 int arrayLength; //数组大小 int heapSize; //堆的大小public: minHeap(int initialCapacity=10); ~minHeap() {delete []heap;} bool empty() const {return heapSize==0;} int size() const {return heapSize;} T&amp; top() const {return heap[1];} //返回堆顶元素 void pop(); //删除堆顶元素 void push(const T&amp; theElement); //向堆中插入一个元素 void initialize(T* theHeap,int theSize);//初始化一个小根堆 void deactivateArray() {heap=NULL;} //从堆的析构函数中保存数组a};template &lt;class T&gt;minHeap&lt;T&gt;::minHeap(int initialCapacity){ heap=new T[initialCapacity+1]; arrayLength=initialCapacity+1; heapSize=0;}template &lt;class T&gt;void minHeap&lt;T&gt;::pop(){//删除堆顶元素 heap[1].~T(); //删除最小元素 //重新构造堆 T lastElement=heap[heapSize--]; //从根开始，为lastElement寻找合适的位置 int currentNode=1,child=2; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(lastElement&lt;=heap[child]) break; heap[currentNode]=heap[child]; currentNode=child; child*=2; } heap[currentNode]=lastElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::push(const T &amp;theElement){//向堆中插入一个元素 if(heapSize==arrayLength-1) //数组已满 { T* newHeap=new T[arrayLength*2]; arrayLength*=2; copy(heap+1,heap+arrayLength,newHeap+1); delete []heap; heap=newHeap; } //为theElement寻找插入位置 int currentNode=++heapSize; while(currentNode!=1 &amp;&amp; theElement&lt;heap[currentNode/2]) {//不能把theElement放入heap[currentNode] heap[currentNode]=heap[currentNode/2]; currentNode/=2; } heap[currentNode]=theElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::initialize(T *theHeap, int theSize){//初始化一个小根堆 delete []heap; heap=theHeap; heapSize=theSize; arrayLength=theSize+1; //堆化 for(int root=heapSize/2;root&gt;=1;root--) { T rootElement=heap[root]; //子树的根 //寻找放置rootElement的位置 int child=2*root; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(rootElement&lt;=heap[child]) break; heap[child/2]=heap[child]; child*=2; } heap[child/2]=rootElement; }}template &lt;class T&gt;void heapSort(T *a, int n){//利用堆排序对数组a[1:n]进行排序 minHeap&lt;T&gt; heap(1); heap.initialize(a,n); for(int i=n-1;i&gt;=1;i--) { T x=heap.top(); heap.pop(); a[i+1]=x; } heap.deactivateArray(); //从堆的析构函数中保存数组a}int main(){ int n;//堆的大小 cin&gt;&gt;n; int *heapElement=new int[n+1]; for(int i=1;i&lt;=n;i++)//第二行n个数，代表堆的各个元素 cin&gt;&gt;heapElement[i]; minHeap&lt;int&gt; H(1); H.initialize(heapElement,n); cout&lt;&lt;H.top()&lt;&lt;endl; int m,instruction,num; //m个操作和当前的操作 cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch(instruction) { case 1: cin&gt;&gt;num; H.push(num); cout&lt;&lt;H.top()&lt;&lt;endl; break; case 2: H.pop(); cout&lt;&lt;H.top()&lt;&lt;endl; break; case 3: cin&gt;&gt;num; int *unsorted=new int[num+1]; for(int k=1;k&lt;=num;k++) cin&gt;&gt;unsorted[k]; heapSort(unsorted,num); for(int k=num;k&gt;=1;k--) cout&lt;&lt;unsorted[k]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; delete []unsorted; break; } } return 0;} P1017:霍夫曼编码格式输入一串小写字母组成的字符串（不超过1000000)。 输出输出这个字符串通过Huffman编码后的长度。 样例输入1abcdabcaba 输出119 限制1s, 1024KiB for each test case. 提示样例中，’a’ 出现了4次，’b’ 出现了3次，’c’ 出现了2次，’d’ 出现了1次编码为: ‘a’ : 0 ‘b’ : 10 ‘c’ : 110 ‘d’ : 111 算法描述&emsp;&emsp;扩充链表存储的二叉树类，增加私有成员WEP，表示Huffman树的WEP值，增加方法computeWEP，计算Huffman树的WEP值，增加方法makeTree，将left，right，element合并成一颗新树。&emsp;&emsp;定义huffmanNode类，表示Huffman树的每个节点。私有成员包括linkedBinaryTree类的指针tree和权值weight。公有成员是对括号的运算符重载，返回weight值。声明类的友元函数HuffmanTree。 HuffmanTree：用权值weight[1:n]构造Huffman树。首先创建一组hNode数组，对于每个hNode[i]，weight值由参数可以得到，tree通过new得到，调用makTree构造出一颗树。创建小根堆heap，heap的每一个元素都是huffmanNode类型，通过小根堆的initialize方法将一组单节点树hNode变成一个小根堆。然后不断从小根堆中取出两棵权值最小的树，将其合并成一个后放入小根堆。函数返回heap.top().tree。 computeWEP：计算Huffman树的WEP值。利用层次遍历，对于遍历到的每个节点，如果其标识为0，则其为内部节点，如果标识不为0，则其为外部节点，根据weight值和当前节点到根节点的路径长度（即层数-1）计算WEP。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//----------------------小根堆----------------------template &lt;class T&gt;class minHeap //小根堆{private: T *heap; //保存堆的数组 int arrayLength; //数组长度 int heapSize; //堆的大小public: minHeap(int initialCapacity=10); ~minHeap() {delete []heap;} bool empty() const {return heapSize==0;} int size() const {return heapSize;} T&amp; top() const {return heap[1];} //返回堆顶元素 void pop(); //删除堆顶元素 void push(const T&amp; theElement); //向堆中插入一个元素 void initialize(T* theHeap,int theSize);//初始化一个小根堆 void heapSort(T* a,int n); //利用堆排序对数组a[1:n]进行排序 void deactivateArray() {heap=NULL;} //从堆的析构函数中保存数组a};template &lt;class T&gt;minHeap&lt;T&gt;::minHeap(int initialCapacity){ heap=new T[initialCapacity+1]; arrayLength=initialCapacity+1; heapSize=0;}template &lt;class T&gt;void minHeap&lt;T&gt;::pop(){//删除堆顶元素 heap[1].~T(); //删除最大元素 //重新构造堆 T lastElement=heap[heapSize--]; //从根开始，为lastElement寻找合适的位置 int currentNode=1,child=2; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(lastElement&lt;=heap[child]) break; heap[currentNode]=heap[child]; currentNode=child; child*=2; } heap[currentNode]=lastElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::push(const T &amp;theElement){//向堆中插入一个元素 if(heapSize==arrayLength-1) //数组已满 { T* newHeap=new T[arrayLength*2]; arrayLength*=2; copy(heap+1,heap+arrayLength,newHeap+1); delete []heap; heap=newHeap; } //为theElement寻找插入位置 int currentNode=++heapSize; while(currentNode!=1 &amp;&amp; theElement&lt;heap[currentNode/2]) {//不能把theElement放入heap[currentNode] heap[currentNode]=heap[currentNode/2]; currentNode/=2; } heap[currentNode]=theElement;}template &lt;class T&gt;void minHeap&lt;T&gt;::initialize(T *theHeap, int theSize){//初始化一个小根堆 delete []heap; heap=theHeap; heapSize=theSize; arrayLength=theSize+1; //堆化 for(int root=heapSize/2;root&gt;=1;root--) { T rootElement=heap[root]; //子树的根 //寻找放置rootElement的位置 int child=2*root; while(child&lt;=heapSize) { if(child&lt;heapSize &amp;&amp; heap[child]&gt;heap[child+1]) child++; if(rootElement&lt;=heap[child]) break; heap[child/2]=heap[child]; child*=2; } heap[child/2]=rootElement; }}//----------------------队列----------------------template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}//----------------------二叉树----------------------template &lt;class T&gt;struct binaryTreeNode //二叉树节点类{ T element; binaryTreeNode&lt;T&gt; *leftChild, *rightChild; //三个构造函数 binaryTreeNode() {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement):element(theElement) {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement,binaryTreeNode&lt;T&gt;* theLeftChild,binaryTreeNode&lt;T&gt;* theRightChild):element(theElement) { leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class linkedBinaryTree{private: binaryTreeNode&lt;T&gt; *root; //根节点指针 int treeSize; //树的节点个数 int WEP; //Huffman树的WEP值 static void (*visit)(binaryTreeNode&lt;T&gt; *); //访问函数 static void preOrder(binaryTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(binaryTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(binaryTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(binaryTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 static void output(binaryTreeNode&lt;T&gt; *t) {cout&lt;&lt;t-&gt;element&lt;&lt;&quot; &quot;;} //输出节点t的element值 int height(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的高度 int nodeNumber(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的节点个数public: linkedBinaryTree() {root=NULL; treeSize=0; WEP=0;} ~linkedBinaryTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void postOrderOutput() //后序输出序列 {postOrder(output);cout&lt;&lt;endl;} void levelOrder(void(*)(binaryTreeNode&lt;T&gt;*)); //层次遍历 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } int Height() const {return height(root);} //计算二叉树的高度 int NodeNumber() const {return nodeNumber(root);} //计算二叉树的节点个数 void initialize(int num); //二叉树的初始化 void subtreeNodeNumber() const; //输出二叉树中所有节点为根的子树的节点个数 void subtreeHeight() const; //输出二叉树中所有节点为根的子树的高度 binaryTreeNode&lt;T&gt;* buildTree(T* pre,T* in,int len); //通过前序序列pre和中序序列in构造一颗二叉树,len表示序列长度 void update(T* pre,T* in,int len); //将构造的二叉树放到对象中，即更新root和treeSize void makeTree(const T&amp; element,linkedBinaryTree&lt;T&gt;&amp; left,linkedBinaryTree&lt;T&gt;&amp; right); //创建一个二叉树，element为根节点元素，left左子树，right为右子树 int computeWEP(int weight[]); //计算Huffman树的WEP值};template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt; *)=NULL; //类的静态成员的初始化template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::preOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { linkedBinaryTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::inOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); linkedBinaryTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::postOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); linkedBinaryTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::height(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int hl=height(t-&gt;leftChild); int hr=height(t-&gt;rightChild); if(hl&gt;hr) return ++hl; else return ++hr;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::nodeNumber(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int nl=nodeNumber(t-&gt;leftChild); int nr=nodeNumber(t-&gt;rightChild); return nl+nr+1;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::levelOrder(void (*theVisit)(binaryTreeNode&lt;T&gt; *)){ binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while (t!=NULL) { theVisit(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else return ; q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::initialize(int num){//二叉树的初始化 //这棵树有num个节点，编号为1~num，根节点为1 //读入编号为i的节点的左孩子a，右孩子b，-1表示该位置没有节点 root=new binaryTreeNode&lt;T&gt;(1); treeSize=num; int *left=new int[num+1]; //左孩子 int *right=new int[num+1]; //右孩子 binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; for(int i=1;i&lt;=num;i++) cin&gt;&gt;left[i]&gt;&gt;right[i]; int cur=t-&gt;element; //当前节点的element值 //利用层次遍历进行初始化 while (t!=NULL) { if(left[cur]!=-1) t-&gt;leftChild=new binaryTreeNode&lt;T&gt;(left[cur]); if(right[cur]!=-1) t-&gt;rightChild=new binaryTreeNode&lt;T&gt;(right[cur]); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //初始化完成 { delete []left; delete []right; return ; } q.pop(); cur=t-&gt;element; }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeNodeNumber() const{//输出二叉树中所有节点为根的子树的节点个数 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的节点个数 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=nodeNumber(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeHeight() const{//输出二叉树中所有节点为根的子树的高度 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的高度 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=height(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;binaryTreeNode&lt;T&gt;* linkedBinaryTree&lt;T&gt;::buildTree(T *pre, T *in, int len){//根据前序序列pre和中序序列in构建二叉树 //len表示序列长度 //返回二叉树的根节点 //序列长度小于等于0，不需要继续构造 if(len&lt;=0) return NULL; binaryTreeNode&lt;T&gt;* subRoot=new binaryTreeNode&lt;T&gt;(pre[0]); //pre[0]为根节点 int index=0; //在中序序列中查找pre[0] for(int i=0;i&lt;len;i++) if(in[i]==pre[0]) { index=i; break; } //递归构造左子树和右子树 subRoot-&gt;leftChild=buildTree(pre+1,in,index); subRoot-&gt;rightChild=buildTree(pre+index+1,in+index+1,len-index-1); return subRoot;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::update(T* pre,T* in,int len){//将构造的二叉树放到对象中，即更新root和treeSize root=buildTree(pre, in, len); treeSize=len;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::makeTree(const T &amp;element, linkedBinaryTree&lt;T&gt; &amp;left, linkedBinaryTree&lt;T&gt; &amp;right){//将left,right和element合并成一颗新树 root=new binaryTreeNode&lt;T&gt;(element,left.root,right.root); treeSize=left.treeSize+right.treeSize+1; left.root=right.root=NULL; left.treeSize=right.treeSize=0;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::computeWEP(int weight[]){//计算Huffman树的WEP值 int road=0; //当前节点到根节点的路径长度 arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; q.push(root); while(1) { int length=q.size(); if(length==0) break; while(length&gt;0) { binaryTreeNode&lt;T&gt;* cur; cur=q.front(); q.pop(); length--; if(cur-&gt;element!=0) WEP+=weight[cur-&gt;element]*road; if(cur-&gt;leftChild!=NULL) q.push(cur-&gt;leftChild); if(cur-&gt;rightChild!=NULL) q.push(cur-&gt;rightChild); } road++; } if(WEP==0) //Huffman树只有根节点 return weight[1]; return WEP;}template &lt;class T&gt;linkedBinaryTree&lt;int&gt;* HuffmanTree(T weight[],int n); //用权值weight[1:n]构造霍夫曼树,n&gt;=1template &lt;class T&gt;class huffmanNode{ friend linkedBinaryTree&lt;int&gt;* HuffmanTree&lt;T&gt;(T weight[],int n); //友元函数的声明public: operator T() const {return weight;}private: linkedBinaryTree&lt;int&gt; *tree; T weight;};template &lt;class T&gt;linkedBinaryTree&lt;int&gt;* HuffmanTree(T weight[],int n){//用权值weight[1:n]构造霍夫曼树,n&gt;=1 //创建一组单节点树hNode数组 huffmanNode&lt;T&gt;* hNode=new huffmanNode&lt;T&gt;[n+1]; linkedBinaryTree&lt;int&gt; emptyTree; for(int i=1;i&lt;=n;i++) { hNode[i].weight=weight[i]; hNode[i].tree=new linkedBinaryTree&lt;int&gt;; hNode[i].tree-&gt;makeTree(i,emptyTree,emptyTree); } //将一组单节点树hNode[1:n]变成一个小根堆 minHeap&lt;huffmanNode&lt;T&gt;&gt; heap(1); heap.initialize(hNode,n); //不断从最小堆中取出两颗树合并成一个放入，直到剩下一颗 huffmanNode&lt;T&gt; w,x,y; linkedBinaryTree&lt;int&gt; *z; for(int i=1;i&lt;n;i++) { //从最小堆中选出两颗权值最小的树 x=heap.top(); heap.pop(); y=heap.top(); heap.pop(); //合并成一颗树w，放入堆 z=new linkedBinaryTree&lt;int&gt;; z-&gt;makeTree(0,*x.tree,*y.tree); w.weight=x.weight+y.weight; w.tree=z; heap.push(w); delete x.tree; delete y.tree; } return heap.top().tree;}int main(){ string str; cin&gt;&gt;str; int t[26]={0}; int weight[27]={0}; int size=0; for(int i=0;i&lt;str.size();i++) t[str.at(i)-'a']++; for(int i=0;i&lt;26;i++) if(t[i]!=0) weight[++size]=t[i]; linkedBinaryTree&lt;int&gt;* p=HuffmanTree(weight,size); cout&lt;&lt;p-&gt;computeWEP(weight)&lt;&lt;endl; return 0;} 结果分析1.模板类声明友元的函数如果是模板函数，声明时需要在友元函数的函数名之后参数之前加上。2.堆排序是不稳定的。3.根据Huffman树求Huffman编码，可以对Huffman树进行后序遍历，利用栈记录走过的分支，如果是左分支，栈内进0，如果是右分支，栈内进1，直到到达一个外部节点，此时栈内记录的就是该节点对应的Huffman编码，然后继续后序遍历，直到遍历结束。","link":"/2020/12/23/DSA/DSA_10/"},{"title":"DSA：（十一）搜索树","text":"&emsp;&emsp;二叉搜索树查找、删除、插入操作的平均性能为O(logn)，最坏情况下的性能为O(n)。索引二叉搜索树为每个节点增加了leftSize域，记录该节点左子树的元素个数，可以按名次进行查找和删除操作，在插入和删除后需要对一些节点的leftSize值进行更新。 P1018:二叉搜索树描述创建带索引的二叉搜索树类。存储结构使用链表，提供操作:插入、删除、按名次删除、查找、按名次查找、升序输出所有元素。 格式输入输入第一行一个数字m (m&lt;=1000000)，表示有m个操作。接下来m行，每一行有两个数字a，b： 当输入的第一个数字a为0时，输入的第二个数字b表示向搜索树中插入b。 当输入的第一个数字a为1时，输入的第二个数字b表示向搜索树中查找b。 当输入的第一个数字a为2时，输入的第二个数字b表示向搜索树中删除b。 当输入的第一个数字a为3时，输入的第二个数字b表示查找搜索树中名次为b的元素。 当输入的第一个数字a为4时，输入的第二个数字b表示删除搜索树中名次为b的元素。 输出对于输入中的每一种操作，输出执行操作的过程中依次比较的元素值的异或值。 注意查询与删除操作中，待查询的元素也需要异或入答案中。查找（删除）操作中，如果未找到，或者插入操作，已存在，输出0（不插入），不需要输出异或和。查找（删除）第b大，如果不存在，输出0。删除操作中，如果当前元素有两个孩子，替换的为右子树中最小的，如果只有一个孩子，直接用该孩子替换当前元素，如果没有孩子，直接删除。删除操作的替换过程中所有比较操作不计入答案。 样例样例1输入1234567891011121314130 60 70 40 50 11 50 73 32 41 53 44 30 4 输出123456789101112130662270723163 样例2输入123456789101112131415140 430 170 550 620 570 660 674 50 670 703 64 70 202 43 输出123456789101112131404343283434963402929915843 限制1s, 10240KiB for each test case. 提示查找和删除第k大的元素时，可以先把第k的元素找到，再按照该元素查找和删除。 算法描述&emsp;&emsp;封装索引二叉搜索树类indexedBinarySearchTree，二叉树的存储结构使用链表，每个节点包括关键字key，左子树的元素个数leftSize，左孩子leftChild，右孩子rightChild。节点类的构造函数有四个，默认构造函数，通过theKey构造，通过theKey，theLeftChild，theRightChild构造（构造函数中计算leftSize值），通过theKey，theLeftSize，theLeftChild，theRightChild构造。索引二叉搜索树类中，非静态的私有成员包括根节点root，树的节点个数treeSize，静态的私有成员包括访问函数visit，前序遍历preOrder，中序遍历inOrder，后序遍历postOrder，删除t指向的节点dispose方法，输出该节点的关键字的output方法。公有成员包括构造函数，析构函数，empty方法，size方法，前序遍历，中序遍历，后序遍历，层次遍历，删除二叉树的erase方法，查找关键字的find方法，插入关键字的insert方法，删除关键字的erase方法，获取名次为b的节点的关键字的get方法，插入操作后更新leftSize域的updateLeftSizeAfterInsert方法，删除操作后更新leftSize域的updateLeftSizeAfterErase_1，updateLeftSizeAfterErase_2方法，两种方法针对删除操作中的两种情况进行相应更新。 find：查找关键字为theKey的节点，如果找到输出查找过程中依次比较的元素值的异或和，如果未找到输出0，不需要输出异或和。指针p从根节点开始搜索，寻找关键字等于theKey的节点，直到p为空为止。循环体首先进行异或操作，然后根据theKey和p-&gt;key的大小关系判断是否找到以及进左子树还是右子树。 insert：插入关键字为theKey的节点，如果不存在关键字为theKey的节点，输出插入过程中依次比较的元素值的异或和，如果已存在关键字为theKey的节点，输出0，不需要输出异或和。指针p从根节点开始搜索，寻找插入的位置，用指针pp保存p的父节点，根据theKey和p-&gt;key的大小关系判断是否已经存在关键字为theKey的节点以及进左子树还是右子树。根据theKey建立一个新节点，根据root是否为空判断是否是插入到一颗空树中，然后通过pp将其连在搜索树上。插入后，treeSize加一，调用updateLeftSizeAfterInsert方法对从根节点到插入点的路径上的节点的leftSize值进行更新。指针x从根节点开始，如果theKey小于x-&gt;key，当前节点的leftSize需要加一，如果theKey大于x-&gt;key，当前节点的leftSize不需要更新。最后输出异或值。 erase：删除关键字为theKey的节点，输出删除过程中依次比较的元素值的异或和，替换过程中的所有比较操作不计入答案。如果当前节点有两个孩子，用右子树中关键字最小的节点进行替换。如果只有一个孩子，直接用该节点的孩子进行替换。如果没有孩子，直接删除。如果不存在，输出0。指针p从根节点开始搜索，pp为p的父节点。搜索完毕后根据p是否为空判断是否存在关键字为theKey的节点。若不存在，输出0然后返回。若存在，根据p的孩子个数分两种情况进行考虑。（1）p有两个孩子：转化为第（2）中情况。在p的右子树中沿着leftChild寻找最小元素s替代被删除的节点。替代过程是根据s-&gt;key，p-&gt;leftSize，p-&gt;leftChild，p-&gt;rightChild新建一个节点，将其连在pp上，更新指针pp，删除p节点，然后让p指向s（这是为了保证（2）中对节点s的删除）。（2）p至多有一个孩子：将孩子指针存在c中，将pp和c连起来，删除p，treeSize减一。最后输出异或值。对leftSize的更新在（1）过程之后（如果有的话），（2）过程之前进行。使用flag标记（1）过程是否进行，如果（1）过程执行，即要删除的节点有两个孩子，调用updateLeftSizeAfterErase_2，否则调用updateLeftSizeAfterErase_1。 updateLeftSizeAfterErase_2：要删除的节点有两个孩子，对从root到p的路径上的节点的leftSize进行更新。参数为节点类的指针s。指针x从根节点开始，当x不等于s时，执行while循环，通过x-&gt;key和s-&gt;key的大小关系进行相应节点的leftSize的更新。注意等于的特殊情况，第一次遇到相等的情况，表示x为替换后的节点，因为是用右子树的最小元素进行替换，所以直接进入右子树即可，第二次遇到表示路径寻找完毕。 updateLeftSizeAfterErase_1：要删除的节点至多有一个孩子，对从root到p的路径上的节点的leftSize进行更新。参数为关键字值theKey。指针x从根节点开始，当x不为空时，执行while循环，通过theKey和x-&gt;key的大小关系进行相应节点的leftSize的更新，若相等则路径寻找完毕。 get：返回第index个元素的关键字的值（index从0开始）。指针x从根节点开始搜索，如果index等于x-&gt;leftSize，则找到该元素，如果index小于x-&gt;leftSize，则第index个元素是左子树的第index个元素，如果index大于x-&gt;leftSize，则第index个元素是右子树的第(index-(x-&gt;leftSize+1))个元素。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct indexedBinarySearchTreeNode{ T key; //关键字 int leftSize; //左子树的元素个数 indexedBinarySearchTreeNode&lt;T&gt; *leftChild,*rightChild; //左孩子和右孩子 indexedBinarySearchTreeNode() { leftChild=rightChild=NULL; leftSize=0; } indexedBinarySearchTreeNode(const T&amp; theKey) { key=theKey; leftChild=rightChild=NULL; leftSize=0; } indexedBinarySearchTreeNode(const T&amp; theKey,indexedBinarySearchTreeNode&lt;T&gt; *theLeftChild,indexedBinarySearchTreeNode&lt;T&gt; *theRightChild) { key=theKey; leftChild=theLeftChild; rightChild=theRightChild; leftSize=0; //计算leftSize的值 indexedBinarySearchTreeNode&lt;T&gt; *p=theLeftChild; while(p!=NULL) //从根沿着右子树的路径计算节点个数 { leftSize+=p-&gt;leftSize+1; p=p-&gt;rightChild; } } indexedBinarySearchTreeNode(const T&amp; theKey,int theLeftSize,indexedBinarySearchTreeNode&lt;T&gt; *theLeftChild,indexedBinarySearchTreeNode&lt;T&gt; *theRightChild) { key=theKey; leftSize=theLeftSize; leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class indexedBinarySearchTree{private: indexedBinarySearchTreeNode&lt;T&gt; *root; //根节点 int treeSize; //树的节点数量 static void (*visit)(indexedBinarySearchTreeNode&lt;T&gt; *); //访问函数 static void preOrder(indexedBinarySearchTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(indexedBinarySearchTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(indexedBinarySearchTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(indexedBinarySearchTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 static void output(indexedBinarySearchTreeNode&lt;T&gt; *t) {cout&lt;&lt;t-&gt;key&lt;&lt;&quot; &quot;;} //输出节点的关键字public: indexedBinarySearchTree() {root=NULL; treeSize=0;} ~indexedBinarySearchTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(indexedBinarySearchTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void inOrderOutput() {inOrder(output); cout&lt;&lt;endl;} //输出中序序列 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } T* find(const T&amp; theKey) const; //查找关键字为theKey的节点 void insert(const T&amp; theKey); //插入关键字为theKey的节点 void erase(const T&amp; theKey); //删除关键字为theKey的节点 T get(int index); //获得名次为b的节点的关键字 void updateLeftSizeAfterInsert(const T&amp; theKey); //插入操作后对leftSize域的更新 void updateLeftSizeAfterErase_1(const T&amp; theKey); //要删除的节点p最多有一个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新 void updateLeftSizeAfterErase_2(indexedBinarySearchTreeNode&lt;T&gt; *s); //要删除的节点p有两个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新};template &lt;class T&gt;void (*indexedBinarySearchTree&lt;T&gt;::visit)(indexedBinarySearchTreeNode&lt;T&gt;*)=NULL; //类的静态成员的初始化template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::preOrder(indexedBinarySearchTreeNode&lt;T&gt; *t){ if(t!=NULL) { indexedBinarySearchTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::inOrder(indexedBinarySearchTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); indexedBinarySearchTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::postOrder(indexedBinarySearchTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); indexedBinarySearchTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;T* indexedBinarySearchTree&lt;T&gt;::find(const T &amp;theKey) const{//查找关键字为theKey的节点 //如果找到输出查找过程中依次比较的元素值的异或和 //如果未找到输出0，不需要输出异或和 int value=0; //异或和 //指针p从根开始搜索，寻找关键字等于theKey的节点 indexedBinarySearchTreeNode&lt;T&gt; *p=root; while(p!=NULL) { value^=p-&gt;key; //异或 if(theKey&lt;p-&gt;key) p=p-&gt;leftChild; else if(theKey&gt;p-&gt;key) p=p-&gt;rightChild; else { cout&lt;&lt;value&lt;&lt;endl; return &amp;p-&gt;key; } } //未找到关键字为theKey的节点 cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return NULL;}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::insert(const T &amp;theKey){//插入关键字为theKey的节点 //如果不存在关键字为theKey的节点，输出插入过程中依次比较的元素值的异或和 //如果已存在关键字为theKey的节点，输出0，不需要输出异或和 int value=0; //异或和 indexedBinarySearchTreeNode&lt;T&gt; *p=root,*pp=NULL; //p从根节点开始，pp为p的父节点 //寻找插入点 while(p!=NULL) { value^=p-&gt;key; //异或 pp=p; //将p移向孩子节点 if(theKey&lt;p-&gt;key) p=p-&gt;leftChild; else if(theKey&gt;p-&gt;key) p=p-&gt;rightChild; else //已存在关键字为theKey的节点 { cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return ; } } //为theKey建立一个新节点，并将该节点连接到pp indexedBinarySearchTreeNode&lt;T&gt; *newNode=new indexedBinarySearchTreeNode&lt;T&gt;(theKey); if(root!=NULL) //树非空 { if(theKey&lt;pp-&gt;key) pp-&gt;leftChild=newNode; else pp-&gt;rightChild=newNode; } else //插入到空树中 root=newNode; //更新treeSize和路径上节点的leftSize treeSize++; updateLeftSizeAfterInsert(theKey); cout&lt;&lt;value&lt;&lt;endl;}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::erase(const T&amp; theKey){//删除关键字为theKey的节点，输出删除过程中依次比较的元素值的异或和，替换过程中的所有比较操作不计入答案 //如果当前节点有两个孩子，用右子树中关键字最小的节点进行替换 //如果只有一个孩子，直接用该节点的孩子进行替换 //如果没有孩子，直接删除 //如果不存在，输出0 int value=0,flag=0; //异或值和标记 indexedBinarySearchTreeNode&lt;T&gt; *p=root,*pp=NULL; while (p!=NULL &amp;&amp; p-&gt;key!=theKey) {//p移动到它的孩子节点 value^=p-&gt;key; pp=p; if(theKey&lt;p-&gt;key) p=p-&gt;leftChild; else p=p-&gt;rightChild; } if(p==NULL) //不存在关键字theKey的节点 { cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; return ; } //重新组织树结构 //当p有两个孩子时的处理 if(p-&gt;leftChild!=NULL &amp;&amp; p-&gt;rightChild!=NULL) {//两个孩子 flag=1; //转化为空或只有一个孩子 //在p的右子树中寻找最小元素 indexedBinarySearchTreeNode&lt;T&gt; *s=p-&gt;rightChild,*ps=p; while(s-&gt;leftChild!=NULL) {//移动到最小元素 ps=s; s=s-&gt;leftChild; } //将最小元素s移动到p indexedBinarySearchTreeNode&lt;T&gt; *q=new indexedBinarySearchTreeNode&lt;T&gt;(s-&gt;key,p-&gt;leftSize,p-&gt;leftChild,p-&gt;rightChild); if(pp==NULL) //p为根节点 root=q; else if(p==pp-&gt;leftChild) pp-&gt;leftChild=q; else pp-&gt;rightChild=q; //更新p和p的父节点 if(ps==p) pp=q; else pp=ps; delete p; p=s; } //在进行删除前更新leftSize if(flag==1) //删除的节点有两个孩子 updateLeftSizeAfterErase_2(p); else //删除的节点最多有一个孩子 updateLeftSizeAfterErase_1(theKey); //p最多有一个孩子 //把孩子指针存放在c indexedBinarySearchTreeNode&lt;T&gt; *c; if(p-&gt;leftChild!=NULL) c=p-&gt;leftChild; else c=p-&gt;rightChild; //删除p if(p==root) root=c; else //p是pp的左孩子还是右孩子 { if(p==pp-&gt;leftChild) pp-&gt;leftChild=c; else pp-&gt;rightChild=c; } treeSize--; delete p; value^=theKey; cout&lt;&lt;value&lt;&lt;endl;}template &lt;class T&gt;T indexedBinarySearchTree&lt;T&gt;::get(int index){//返回第index个元素的关键字的值 //index从0开始 indexedBinarySearchTreeNode&lt;T&gt; *x=root; while(x!=NULL) { if(index==x-&gt;leftSize) //第index个元素是x-&gt;key break; else if(index&lt;x-&gt;leftSize) //第index个元素是左子树的第index个元素 x=x-&gt;leftChild; else //第index个元素是右子树的第(index-(x-&gt;leftSize+1))个元素 { index=index-(x-&gt;leftSize+1); x=x-&gt;rightChild; } } return x-&gt;key;}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::updateLeftSizeAfterInsert(const T &amp;theKey){//插入操作后对leftSize域的更新 indexedBinarySearchTreeNode&lt;T&gt; *x=root; //寻找从根开始到关键字为theKey的节点的路径 while(x!=NULL) { if(theKey&lt;x-&gt;key) //插入节点在x的左子树中，leftSize++ { x-&gt;leftSize++; x=x-&gt;leftChild; } else if(theKey&gt;x-&gt;key) //插入节点在x的右子树中 x=x-&gt;rightChild; else //路径寻找完毕 break; }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::updateLeftSizeAfterErase_1(const T &amp;theKey){//要删除的节点p最多有一个孩子，删除操作后对root到p的路径上节点的leftSize域 indexedBinarySearchTreeNode&lt;T&gt; *x=root; //寻找从根开始到关键字为theKey的节点的路径 while(x!=NULL) { if(theKey&lt;x-&gt;key) //删除节点在x的左子树中，leftSize-- { x-&gt;leftSize--; x=x-&gt;leftChild; } else if(theKey&gt;x-&gt;key) //删除节点在x的右子树中 x=x-&gt;rightChild; else //路径寻找完毕 break; }}template &lt;class T&gt;void indexedBinarySearchTree&lt;T&gt;::updateLeftSizeAfterErase_2(indexedBinarySearchTreeNode&lt;T&gt; *s){//要删除的节点p有两个孩子，删除操作后对root到p的路径上节点的leftSize域进行更新 indexedBinarySearchTreeNode&lt;T&gt; *x=root; bool meet=false; //标记是否是第一次遇到关键字为s-&gt;key的节点 //寻找从根开始到s的路径 while(x!=s) { if(s-&gt;key&lt;x-&gt;key) //删除节点在x的左子树中，leftSize-- { x-&gt;leftSize--; x=x-&gt;leftChild; } else if(s-&gt;key&gt;x-&gt;key) //删除节点在x的右子树中 x=x-&gt;rightChild; else { if(!meet) //第一次遇到相同关键字的节点 { meet=true; //这个节点的关键字已经被右子树的最小元素替换 x=x-&gt;rightChild; //要删除的节点位于右子树，所以将指针指向右孩子 } else //第二次遇到，路径寻找完毕 break; } }}int main(){ indexedBinarySearchTree&lt;int&gt; IBST; int m,instruction,b; cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch (instruction) { case 0: cin&gt;&gt;b; IBST.insert(b); break; case 1: cin&gt;&gt;b; IBST.find(b); break; case 2: cin&gt;&gt;b; IBST.erase(b); break; case 3: cin&gt;&gt;b; IBST.find(IBST.get(b-1)); break; default: cin&gt;&gt;b; IBST.erase(IBST.get(b-1)); } } return 0;} 结果分析1.updateLeftSizeAfterErase_1和updateLeftSizeAfterErase_2可以合并成updateLeftSize AfterErase，参数为索引二叉搜索树节点类的指针。while循环条件是x!=s，如果s-&gt;key小于x-&gt;key，x-&gt;leftSize减一，x=x-&gt;leftChild，否则x=x-&gt;rightChild。2.插入节点时，对leftSize更新不能边寻找边更新，因为有可能该节点已经存在，不需要再插入，所以需要在插入操作完成后再根据theKey更新。","link":"/2020/12/23/DSA/DSA_11/"},{"title":"DSA：（十二）图","text":"&emsp;&emsp;图的表示可以通过邻接矩阵，邻接链表和邻接数组。本文通过邻接链表实现无向无权图的表示，成员方法包括插入一条边，删除一条边，广度优先搜索，深度优先搜索，求连通分量个数，求两点之间的最短路径（BFS）。linkedGraph类中含有迭代器类myIterator，通过顶点创建迭代器，依次返回该顶点的所有邻接点。 P1019:图论基础描述创建无向图类，存储结构使用邻接链表，提供操作：插入一条边，删除一条边，BFS，DFS。 格式输入第一行四个整数n，m，s，t。n (10≤n≤100000) 代表图中点的个数，m (10≤m≤200000) 代表接下来共有m个操作，s代表起始点，t代表终点。接下来m行，每行代表一次插入或删除边的操作，操作格式为： 0 u v 在点u和v之间增加一条边 1 u v 删除点u和v之间的边 输出第一行输出图中有多少个连通分量。第二行输出所有连通子图中最小点的编号（升序），编号间用空格分隔。第三行输出从s点开始的dfs序列长度。第四行输出从s点开始的字典序最小的dfs序列。第五行输出从t点开始的bfs序列的长度。第六行输出从t点开始字典序最小的bfs序列。第七行输出从s点到t点的最短路径，若是不存在路径则输出-1。 样例输入12345678910111213141516171819202110 20 4 50 6 40 10 30 4 80 4 101 4 100 2 10 5 80 5 20 10 70 9 60 9 10 7 10 8 100 7 50 8 30 6 71 6 41 8 30 7 80 9 2 输出123456711 104 8 5 2 1 7 6 9 10 3 105 2 7 8 1 9 6 10 4 3 2 限制1s, 10240KiB for each test case. 算法描述&emsp;&emsp;使用邻接链表存储结构，封装无向图类linkedGraph。protected成员包括图的顶点数n，边数e，邻接表aList，深度优先搜索递归方法rDfs，静态成员标记数组reach，标记label，路径数组path，路径长度length。public成员包括构造函数，析构函数，返回顶点个数，返回边数，插入一条边，删除一条边，广度优先搜索，深度优先搜索，返回无向图的构件个数，通过BFS求两点之间的最短路径，对aList链表数组的每个元素进行排序。定义迭代器myIterator，提供next方法依次返回当前顶点的邻接顶点，若不存在返回0。方法iterator返回myIterator类的指针。&emsp;&emsp;对chain类进行扩展，增加方法eraseElement(theVertex)删除顶点为theVertex的元素和冒泡排序方法bubbleSort。 insertEdge：插入一条边i, j。首先通过aList[i].indexOf(j)判断图中是否已经存在这条边，若已经存在则不需要再次插入，若不存在，调用aList[i]和aList[j]的insert方法，将邻接顶点插入到链表头，图的边数e加一。 eraseEdge：删除一条边i, j。首先通过aList[i].eraseElement (j)判断图中是否存在这条边，若不存在则不需要进行删除，若存在，调用aList[i]和aList[j]的eraseElement方法删除邻接点，图的边数e减一。 labelComponents：返回无向图的构件个数。首先将标记构件号的数组c和标记label初始化，然后遍历每个顶点，如果顶点i未到达，对其实施BFS，进行标记。 findPath：寻找一条从顶点theSource到顶点theDestination的最短路径，返回一个数组path，从索引1开始表示路径，path[0]表示路径长度。如果路径不存在，返回NULL。首先对path，length，reach等进行初始化，定义bool型变量exists表示路径是否存在，用parent数组存储每个节点的前驱节点。利用BFS搜索路径，每次从队列中删除一个有标记的顶点，判断是否到达theDestination，若未到达，则标记所有邻接于顶点w的还未到达的顶点，使用parent数组存储前驱节点。如果到达theDestination，exists赋值为true，跳出while循环。如果找到了最短路径，根据parent逆向寻找路径中的各个顶点，通过栈结构将其放入path数组中，path[0]记录路径长度。如果不存在路径，输出-1然后返回。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839#include &lt;iostream&gt;using namespace std;//---------------------graphChain类---------------------template &lt;class T&gt;struct chainNode //节点类{ //数据成员 T element; chainNode&lt;T&gt;* next; //方法 chainNode() {} chainNode(const T&amp; element) { this-&gt;element=element; } chainNode(const T&amp; element,chainNode&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};class linkedGraph;template &lt;class T&gt;class graphChain{ friend class linkedGraph;protected: chainNode&lt;T&gt;* firstNode; //指向链表第一个节点的指针 int listSize; //线性表的元素个数public: graphChain(); //构造函数 graphChain(const graphChain&lt;T&gt;&amp; theList); //复制构造函数 ~graphChain(); //析构函数 //方法 bool empty() const {return listSize==0;} int size() const {return listSize;} T&amp; get(int theIndex) const; int indexOf(const T&amp; theElement); //返回元素theElement首次出现时的索引，若不存在返回-1 void insert(int theIndex,const T&amp; theElement); //在索引为theIndex的位置插入元素theElement void erase(int theIndex); //删除链表中索引为theIndex的元素 T* eraseElement(T&amp; theVertex); //删除顶点为theVertex的元素 void bubbleSort(); //冒泡排序 //迭代器 class iterator { protected: chainNode&lt;T&gt;* node; public: //用C++的typedef语句实现前向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(chainNode&lt;T&gt;* theNode=NULL) //构造函数 { node=theNode; } //解引用操作符 T&amp; operator* () const {return node-&gt;element;} T* operator-&gt; () const {return &amp;node-&gt;element;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { node=node-&gt;next; return *this; } iterator operator++ (int)//后++ { iterator old=*this; node=node-&gt;next; return old; } //相等检验 bool operator!= (const iterator&amp; right) const { return node!=right.node; } bool operator== (const iterator&amp; right) const { return node==right.node; } }; iterator begin() const { return iterator(firstNode); } iterator end() const { return iterator(NULL); }};template &lt;class T&gt;graphChain&lt;T&gt;::graphChain() //构造函数{ firstNode=NULL; listSize=0;}template &lt;class T&gt;graphChain&lt;T&gt;::graphChain(const graphChain&lt;T&gt;&amp; theList) //复制构造函数{ listSize=theList.listSize; //链表为空 if(listSize==0) { firstNode=NULL; return ; } //链表不为空 chainNode&lt;T&gt;* sourceNode=theList.firstNode; firstNode=new chainNode&lt;T&gt;(sourceNode-&gt;element);//复制theList的首元素 sourceNode=sourceNode-&gt;next; chainNode&lt;T&gt;* targetNode=firstNode; while(sourceNode!=NULL) //复制剩余元素 { targetNode-&gt;next=new chainNode&lt;T&gt;(sourceNode-&gt;element); targetNode=targetNode-&gt;next; sourceNode=sourceNode-&gt;next; } targetNode-&gt;next=NULL; //尾结点}template &lt;class T&gt;graphChain&lt;T&gt;::~graphChain() //析构函数{ while(firstNode!=NULL) { chainNode&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;T&amp; graphChain&lt;T&gt;::get(int theIndex) const{//返回索引为theIndex的元素 //移向需要的节点 chainNode&lt;T&gt;* currentNode=firstNode; for(int i=0;i&lt;theIndex;i++) currentNode=currentNode-&gt;next; return currentNode-&gt;element;}template &lt;class T&gt;int graphChain&lt;T&gt;::indexOf(const T&amp; theElement){//返回元素theElement首次出现时的索引，若不存在返回-1 //搜索链表寻找theElement chainNode&lt;T&gt;* currentNode=firstNode; int index=0; while (currentNode!=NULL &amp;&amp; currentNode-&gt;element!=theElement) { currentNode=currentNode-&gt;next; index++; } if(currentNode==NULL) return -1; else return index;}template &lt;class T&gt;void graphChain&lt;T&gt;::insert(int theIndex,const T&amp; theElement) //插入操作{//在索引为theIndex的位置插入元素theElement if(theIndex==0)//在链表头插入 firstNode=new chainNode&lt;T&gt;(theElement,firstNode); else { //寻找前驱 chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;theIndex-1;i++) p=p-&gt;next; //在p之后插入 p-&gt;next=new chainNode&lt;T&gt;(theElement,p-&gt;next); } listSize++;}template &lt;class T&gt;void graphChain&lt;T&gt;::erase(int theIndex){//删除链表中索引为theIndex的元素 chainNode&lt;T&gt;* deleteNode; if(theIndex==0) {//删除链表的首节点 deleteNode=firstNode; firstNode=firstNode-&gt;next; } else { chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;theIndex-1;i++) p=p-&gt;next; deleteNode=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; } listSize--; delete deleteNode;}template &lt;class T&gt;T* graphChain&lt;T&gt;::eraseElement(T &amp;theVertex){//删除顶点为theVertex的元素 chainNode&lt;T&gt;* deleteNode; //要删除的节点 if(firstNode-&gt;element==theVertex) //删除的是链表的首节点 { deleteNode=firstNode; firstNode=firstNode-&gt;next; } else //删除的不是链表的首节点 { chainNode&lt;T&gt;* previousNode=firstNode; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=theVertex) { currentNode=currentNode-&gt;next; previousNode=previousNode-&gt;next; } if(currentNode==NULL) //链表中不存在要删除的元素 return NULL; else //链表中存在要删除的元素 { deleteNode=currentNode; previousNode-&gt;next=currentNode-&gt;next; } } T* pElement=&amp;deleteNode-&gt;element; listSize--; delete deleteNode; return pElement;}template &lt;class T&gt;void graphChain&lt;T&gt;::bubbleSort(){//冒泡排序 for(chainNode&lt;T&gt;* p=firstNode;p!=NULL;p=p-&gt;next) for(chainNode&lt;T&gt;* q=p-&gt;next;q!= NULL;q=q-&gt;next) if(p-&gt;element &gt; q-&gt;element) swap(p-&gt;element,q-&gt;element);}//---------------------arrayQueue类---------------------template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}//---------------------arrayStack类---------------------template &lt;class T&gt;class arrayStack{private: int stackTop; //栈顶 int arrayLength; //栈容量 T* stack; //元素数组public: //构造函数、析构函数 arrayStack(int initialCapacity=10); ~arrayStack() {delete []stack;} //ADT方法 bool empty() const {return stackTop==-1;} int size() const {return stackTop+1;} T&amp; top(); void pop(); void push(const T&amp; theElement);};template &lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity){ arrayLength=initialCapacity; stack=new T[arrayLength]; stackTop=-1;}template &lt;class T&gt;T&amp; arrayStack&lt;T&gt;::top(){ return stack[stackTop];}template &lt;class T&gt;void arrayStack&lt;T&gt;::pop(){ stack[stackTop--].~T();}template &lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement){ if(stackTop==arrayLength-1) {//空间已满，容量加倍 T* newStack=new T[arrayLength*2]; arrayLength*=2; for(int i=0;i&lt;=stackTop;i++) newStack[i]=stack[i]; delete []stack; stack=newStack; } //在栈顶插入 stack[++stackTop]=theElement;}//---------------------linkedGraph类---------------------class linkedGraph{protected: int n; //顶点数 int e; //边数 graphChain&lt;int&gt; *aList; //邻接表 void rDfs(int v); //深度优先搜索递归方法 void rDfs_output(int v); //深度优先搜索递归方法（输出DFS序列） static int *reach; //标记数组 static int label; //标记 static int *path; //路径 static int length; //路径长度public: linkedGraph(int numberOfVertices=0) {//构造函数 n=numberOfVertices; e=0; aList=new graphChain&lt;int&gt;[n+1]; } ~linkedGraph() {delete []aList;} int numberOfVertices() const {return n;} //返回顶点数 int numberOfEdges() const {return e;} //返回边数 void insertEdge(int i,int j); //插入一条边 void eraseEdge(int i,int j); //删除一条边 void bfs(int v,int reach[],int label); //广度优先搜索 void bfs_output(int v,int reach[],int label); //广度优先搜索（输出BFS序列） void dfs(int v,int reach[],int label); //深度优先搜索 void dfs_output(int v,int reach[],int label); //深度优先搜索（输出DFS序列） int labelComponents(int c[]); //返回无向图的构件个数 int* findPath(int theSource,int theDestination);//通过BFS求两点之间的最短路径 void sortedAList() //对aList[i]进行排序 { for(int i=1;i&lt;=n;i++) aList[i].bubbleSort(); } //迭代器 class myIterator { protected: graphChain&lt;int&gt; chain; chainNode&lt;int&gt;* currentVertexNode; public: myIterator(graphChain&lt;int&gt;&amp; theGraphChain) { chain=theGraphChain; currentVertexNode=chain.firstNode; } ~myIterator() {chain.firstNode=NULL;} int next() {//返回下一个顶点。若不存在则返回0 //寻找下一个邻接的顶点 while(currentVertexNode!=NULL) { chainNode&lt;int&gt;* p=currentVertexNode; currentVertexNode=currentVertexNode-&gt;next; return p-&gt;element; } //不存在下一个邻接的顶点 return 0; } }; myIterator* iterator(int theVertex) //访问指定顶点的相邻顶点 {//返回顶点theVertex的迭代器 return new myIterator(aList[theVertex]); }};int* linkedGraph::reach=NULL; //标记数组int linkedGraph::label=0; //标记int* linkedGraph::path=NULL; //路径int linkedGraph::length=0; //路径长度void linkedGraph::insertEdge(int i,int j){//插入一条边i,j //判断是否是新边 if(aList[i].indexOf(j)==-1) { aList[i].insert(0,j); aList[j].insert(0,i); e++; }}void linkedGraph::eraseEdge(int i,int j){//删除一条边i,j //判断边i,j是否存在 int *v=aList[i].eraseElement(j); if(v!=NULL) { aList[j].eraseElement(i); e--; }}int linkedGraph::labelComponents(int *c){//返回无向图的构件个数 //令所有顶点是非构件 for(int i=0;i&lt;=n;i++) c[i]=0; label=0; //确定构件 for(int i=1;i&lt;=n;i++) { if(c[i]==0) //顶点i未到达 { label++; bfs(i,c,label); //给新构件做标记 } } return label;}void linkedGraph::bfs(int v,int reach[],int label){ arrayQueue&lt;int&gt; q(10); reach[v]=label; q.push(v); while (!q.empty()) { //从队列中删除一个有标记的顶点 int w=q.front(); q.pop(); //标记所有邻接于顶点w的还没有到达的顶点 for(chainNode&lt;int&gt;* u=aList[w].firstNode;u!=NULL;u=u-&gt;next) { //访问顶点w的一个关联的顶点 if(reach[u-&gt;element]==0) {//u-&gt;element是一个没有到达的顶点 q.push(u-&gt;element); reach[u-&gt;element]=label; //到达标记 } } }}void linkedGraph::bfs_output(int v,int reach[],int label){ arrayQueue&lt;int&gt; q(10); reach[v]=label; cout&lt;&lt;v&lt;&lt;&quot; &quot;; q.push(v); while (!q.empty()) { //从队列中删除一个有标记的顶点 int w=q.front(); q.pop(); //标记所有邻接于顶点w的还没有到达的顶点 for(chainNode&lt;int&gt;* u=aList[w].firstNode;u!=NULL;u=u-&gt;next) { //访问顶点w的一个关联的顶点 if(reach[u-&gt;element]==0) {//u-&gt;element是一个没有到达的顶点 q.push(u-&gt;element); reach[u-&gt;element]=label; //到达标记 cout&lt;&lt;u-&gt;element&lt;&lt;&quot; &quot;; } } } cout&lt;&lt;endl;}void linkedGraph::dfs(int v,int reach[],int label){ linkedGraph::reach=reach; linkedGraph::label=label; rDfs(v);}void linkedGraph::rDfs(int v){//深度优先搜索递归方法 reach[v]=label; myIterator* iv=iterator(v); int u; while((u=iv-&gt;next())!=0) //访问与v相邻的顶点 if(reach[u]==0) rDfs(u); //u是一个没有到达的顶点 delete iv;}void linkedGraph::dfs_output(int v,int reach[],int label){ linkedGraph::reach=reach; linkedGraph::label=label; rDfs_output(v);}void linkedGraph::rDfs_output(int v){//深度优先搜索递归方法 reach[v]=label; cout&lt;&lt;v&lt;&lt;&quot; &quot;; myIterator* iv=iterator(v); int u; while((u=iv-&gt;next())!=0) //访问与v相邻的顶点 if(reach[u]==0) rDfs_output(u); //u是一个没有到达的顶点 delete iv;}int* linkedGraph::findPath(int theSource, int theDestination){//寻找一条从顶点theSource到顶点theDestination的最短路径 //返回一个数组path，从索引1开始表示路径，path[0]表示路径长度 //如果路径不存在，返回NULL //为寻找路径的算法初始化 bool exists=false; path=new int[n+1]; path[1]=theSource; length=0; int *parent=new int[n+1]; //节点的父节点 reach=new int[n+1]; for(int i=1;i&lt;=n;i++) reach[i]=0; //搜索路径 arrayQueue&lt;int&gt; q(10); reach[theSource]=1; q.push(theSource); while (!q.empty()) { //从队列中删除一个有标记的顶点 int w=q.front(); q.pop(); if(w==theDestination) //到达theDestination { exists=true; break; } //标记所有邻接于顶点w的还没有到达的顶点 for(chainNode&lt;int&gt;* u=aList[w].firstNode;u!=NULL;u=u-&gt;next) { //访问顶点w的一个关联的顶点 if(reach[u-&gt;element]==0) {//u-&gt;element是一个没有到达的顶点 q.push(u-&gt;element); reach[u-&gt;element]=label; //到达标记 parent[u-&gt;element]=w; //存储父节点 } } } if(theSource==theDestination || exists) //找到一条最短路径 { //根据parent逆向寻找路径 int i=theDestination; arrayStack&lt;int&gt; stack; stack.push(theDestination); //入栈 while (parent[i]!=theSource) { stack.push(parent[i]); i=parent[i]; } length=stack.size(); path[0]=length; //出栈 for(int k=2;k&lt;=length+1;k++) { path[k]=stack.top(); stack.pop(); } cout&lt;&lt;path[0]&lt;&lt;endl; } else //不存在路径 { delete []path; path=NULL; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; } delete []reach; delete []parent; return path;}template &lt;class T&gt;void bubble_sort(T* array,int size) //及时终止的冒泡排序{ bool sorted=false; //判断是否有序 for(int i=0;i&lt;size-1&amp;&amp;!sorted;i++)//size个数最多进行(size-1)次冒泡 { sorted=true; //每次初始化为有序 for(int j=0;j&lt;size-1-i;j++) { if(array[j+1]&lt;array[j]) { swap(array[j],array[j+1]); sorted = false; //发生了交换,仍处于无序状态 } } }}int main(){ int n,m,s,t; //n个顶点，m个操作，s代表起始点，t代表终点 cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t; int instruction,u,v; linkedGraph LG(n); //构建图 for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction&gt;&gt;u&gt;&gt;v; if(instruction==0) LG.insertEdge(u,v); else LG.eraseEdge(u,v); } int *c=new int[n+1]; //c[i]是顶点i的构件号 int *reachDFS=new int[n+1]; //DFS搜索时的标记数组 int *reachBFS=new int[n+1]; //BFS搜索时的标记数组 int cntDFS=0,cntBFS=0; //DFS和BFS序列长度 for(int i=1;i&lt;=n;i++) //初始化 reachDFS[i]=reachBFS[i]=0; //第一行输出图中有多少个连通分量 int components=LG.labelComponents(c); cout&lt;&lt;components&lt;&lt;endl; //第二行输出所有连通子图中最小点的编号（升序），编号间用空格分隔 int *min=new int[components]; //每个连通子图中的最小点的编号 for(int i=0;i&lt;components;i++) //初始化 min[i]=0; for(int i=1;i&lt;=n;i++) { if(min[c[i]-1]==0) min[c[i]-1]=i; else { if(i&lt;min[c[i]-1]) min[c[i]-1]=i; } } //对min[i]排序后输出 bubble_sort(min,components); for(int i=0;i&lt;components;i++) cout&lt;&lt;min[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; //第三行输出从s点开始的dfs序列长度 LG.dfs(s,reachDFS,1); for(int i=1;i&lt;=n;i++) if(reachDFS[i]==1) cntDFS++; cout&lt;&lt;cntDFS&lt;&lt;endl; //第四行输出从s点开始的字典序最小的dfs序列 LG.sortedAList(); for(int i=1;i&lt;=n;i++) reachDFS[i]=0; LG.dfs_output(s,reachDFS,1); cout&lt;&lt;endl; //第五行输出从t点开始的bfs序列的长度 LG.bfs(t,reachBFS,1); for(int i=1;i&lt;=n;i++) if(reachBFS[i]==1) cntBFS++; cout&lt;&lt;cntBFS&lt;&lt;endl; //第六行输出从t点开始字典序最小的bfs序列 LG.sortedAList(); for(int i=1;i&lt;=n;i++) reachBFS[i]=0; LG.bfs_output(t,reachBFS,1); //第七行输出从s点到t点的最短路径，若是不存在路径则输出-1 int *path=LG.findPath(s,t); //释放内存 delete []c; delete []reachDFS; delete []reachBFS; delete []path; delete []min; return 0;} 结果分析1.求字典序最小的BFS和DFS序列，一种办法是在求之前对邻接表的每个链表排序，另一种办法是在插入边的时候，按照有序链表进行插入。2.求所有连通子图最小点的编号，需要先求出连通子图个数，然后根据连通子图个数声明一个数组，用来保存每个连通子图的最小点编号。遍历所有顶点，根据该顶点的label值和数组中已经存储的编号，最终得到所有连通子图最小点的编号。进行排序后，即可按照升序输出。3.求无权图中两个点之间的最短路径，使用BFS搜索即可，在搜索过程中保存当前节点的前驱节点，搜索结束后逆向寻找这条路径中的各个顶点。","link":"/2020/12/23/DSA/DSA_12/"},{"title":"DSA：（四）链式描述线性表","text":"&emsp;&emsp;本文通过两个具体的题目实现线性表的链式描述，并为链表类封装了前向迭代器，链表类的方法包括插入、删除、原地逆置、查询、输出异或和、箱子排序、二路归并。 P1005:链表实现要求1.封装链表类，链表迭代器类。2.链表类需提供操作：在指定位置插入元素，删除指定元素，搜索链表中是否有指定元素，原地逆置链表，输出链表。3.不得使用与链表实现相关的STL。 描述第一行两个整数N和Q。第二行N个整数，作为节点的元素值，创建链表。接下来Q行，执行各个操作，具体格式如下： 12345插入操作: 1 idx val //在链表的idx位置插入元素val删除操作: 2 val //删除链表中的val元素。若链表中存在多个该元素，仅删除第一个。若该元素不存在，输出-1逆置操作: 3 //原地逆置链表查询操作: 4 val //查询链表中的 val 元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引。若不存在该元素，输出-1输出操作: 5 //使用链表迭代器，输出当前链表索引与元素的异或和 样例输入点击右上角可直接复制。 12345678910111210 106863 35084 11427 53377 34937 14116 5000 49692 70281 73704 4 68631 2 4419954 214661 6 1148354 3493754 68631 10 18635 输出12345670398665-141014154101410 限制1s 算法描述&emsp;&emsp;定义结构体chainNode，数据成员包含element和next，element为数据域，next为指针域。方法包括三个重载的构造函数，默认构造函数，通过元素element创建节点，通过元素element和指针next创建节点。&emsp;&emsp;使用链式存储结构，封装链表类chain，保护成员包括指向链表首节点的指针firstNode和链表长度listSize。公有成员包括构造函数，复制构造函数，析构函数，以及具体的方法，包括插入操作，删除操作，原地逆置操作，查询操作，输出操作。&emsp;&emsp;定义链表类的迭代器iterator，保护成员为节点类的指针node，公有成员包括构造函数，操作符重载函数（解引用操作符 * 和-&gt;，前++，后++，相等检验中的!=和==），在chain类中增加方法begin和end，返回指向链表首元素的指针和尾元素的指针。&emsp;&emsp;读入数据时，按行读入，首先读入操作数instruction，根据操作数利用switch分支进行分类，再根据所属操作类别读入对应的数据，调用对应的成员函数，输出数据。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct chainNode //节点类{ //数据成员 T element; chainNode&lt;T&gt;* next; //方法 chainNode() {} chainNode(const T&amp; element) { this-&gt;element=element; } chainNode(const T&amp; element,chainNode&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};template &lt;class T&gt;class chain //链表类{protected: chainNode&lt;T&gt;* firstNode; //指向链表第一个节点的指针 int listSize; //线性表的元素个数public: chain(); //构造函数 chain(const chain&lt;T&gt;&amp; theList); //复制构造函数 ~chain(); //析构函数 //方法 void insert(int idx,const T&amp; val); //在链表的idx位置插入元素val void erase(const T&amp; val); //删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 void reverse(); //原地逆置链表 int search(const T&amp; val) const; //查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 int output() const; //输出当前链表索引与元素的异或和 //迭代器 class iterator { protected: chainNode&lt;T&gt;* node; public: //用C++的typedef语句实现前向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(chainNode&lt;T&gt;* theNode=NULL) //构造函数 { node=theNode; } //解引用操作符 T&amp; operator* () const {return node-&gt;element;} T* operator-&gt; () const {return &amp;node-&gt;element;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { node=node-&gt;next; return *this; } iterator operator++ (int)//后++ { iterator old=*this; node=node-&gt;next; return old; } //相等检验 bool operator!= (const iterator&amp; right) const { return node!=right.node; } bool operator== (const iterator&amp; right) const { return node==right.node; } }; iterator begin() const { return iterator(firstNode); } iterator end() const { return iterator(NULL); }};template &lt;class T&gt;chain&lt;T&gt;::chain() //构造函数{ firstNode=NULL; listSize=0;}template &lt;class T&gt;chain&lt;T&gt;::chain(const chain&lt;T&gt;&amp; theList) //复制构造函数{ listSize=theList.listSize; //链表为空 if(listSize==0) { firstNode=NULL; return ; } //链表不为空 chainNode&lt;T&gt;* sourceNode=theList.firstNode; firstNode=new chainNode&lt;T&gt;(sourceNode-&gt;element);//复制theList的首元素 sourceNode=sourceNode-&gt;next; chainNode&lt;T&gt;* targetNode=firstNode; while(sourceNode!=NULL) //复制剩余元素 { targetNode-&gt;next=new chainNode&lt;T&gt;(sourceNode-&gt;element); targetNode=targetNode-&gt;next; sourceNode=sourceNode-&gt;next; } targetNode-&gt;next=NULL; //尾结点}template &lt;class T&gt;chain&lt;T&gt;::~chain() //析构函数{ while(firstNode!=NULL) { chainNode&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;void chain&lt;T&gt;::insert(int idx,const T&amp; val) //插入操作{//在链表的idx位置插入元素val if(idx==0)//在链表头插入 { firstNode=new chainNode&lt;T&gt;(val,firstNode); } else { //寻找前驱 chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;idx-1;i++) p=p-&gt;next; //在p之后插入 p-&gt;next=new chainNode&lt;T&gt;(val,p-&gt;next); } listSize++;}template &lt;class T&gt;void chain&lt;T&gt;::erase(const T&amp; val) //删除操作{//删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 chainNode&lt;T&gt;* deleteNode; //要删除的节点 if(firstNode-&gt;element==val) //删除的是链表的首节点 { deleteNode=firstNode; firstNode=firstNode-&gt;next; } else //删除的不是链表的首节点 { chainNode&lt;T&gt;* previousNode=firstNode; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; previousNode=previousNode-&gt;next; } if(currentNode==NULL) //链表中不存在要删除的元素 { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return ; } else //链表中存在要删除的元素 { deleteNode=currentNode; previousNode-&gt;next=currentNode-&gt;next; } } listSize--; delete deleteNode;}template &lt;class T&gt;void chain&lt;T&gt;::reverse() //原地逆置{ if(listSize==0) //链表为空 return ; else { chainNode&lt;T&gt;* currentNode=firstNode; //当前节点 while(currentNode-&gt;next) //当前节点还有后继元素 { chainNode&lt;T&gt;* p=currentNode-&gt;next; //储存当前节点的后继元素 currentNode-&gt;next=p-&gt;next; //将p断开 p-&gt;next=firstNode; //将p连在首节点的前面 firstNode=p; //设置p为首节点 } }}template &lt;class T&gt;int chain&lt;T&gt;::search(const T&amp; val) const //查询操作{//查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 chainNode&lt;T&gt;* currentNode=firstNode; int index=0; //当前节点的索引 while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; //移向下一个节点 index++; } //确定是否找到元素 if(currentNode!=NULL) return index; else { return -1; }}template &lt;class T&gt;int chain&lt;T&gt;::output() const //输出输出当前链表索引与元素的异或和{ int res=0,index=0; for(iterator i=this-&gt;begin();i!=this-&gt;end();i++) //通过迭代器遍历链表 { res+=index^*i; index++; } return res;}int main(){ int n,q; //n个整数 q行操作 int value; //读取初始链表的各个元素值 int instruction; //指令编号 int idx,val; //读入的索引、元素信息 cin&gt;&gt;n&gt;&gt;q; chain&lt;int&gt; A; //创建对象 for(int i=0;i&lt;n;i++) //将数据插入链表 { cin&gt;&gt;value; A.insert(i,value); } //执行各项操作 for(int i=0;i&lt;q;i++) { cin&gt;&gt;instruction; switch(instruction) { case 1: //插入操作 cin&gt;&gt;idx&gt;&gt;val; A.insert(idx,val); break; case 2: //删除操作 cin&gt;&gt;val; A.erase(val); break; case 3: //原地逆置 A.reverse(); break; case 4: //查询操作 cin&gt;&gt;val; cout&lt;&lt;A.search(val)&lt;&lt;endl; break; case 5: //输出操作 cout&lt;&lt;A.output()&lt;&lt;endl; break; } } return 0;} 结果分析1.迭代器可以理解为广义的指针，在链表的一些操作中，使用迭代器会减少一些操作的时间复杂度。例如，在链表chain中，从左至右访问线性表的元素时，使用get方法和使用迭代器方法，在运行时间上的差别是很大的。如果一次考察一个元素，get方法的时间复杂度为O(n^2)，迭代器方法的时间复杂度为O(n)。2.对chain类可以扩展一些ADT方法，比如clear（清除表中所有元素）和push_back(theElement)（将元素theElement插入表尾）。以chain类为基类，派生出extendedChain类，在extendedChain类中增加protected成员lastNode，实现方法clear和push_back，改进erase和insert方法。 P1006:链表合并要求1.使用题目“链表实现”中实现的链表类、迭代器类完成本题。2.不得使用与题目实现相关的STL。 描述给定两组整数序列，你需要分别创建两个有序链表，使用链表迭代器实现链表的合并，并分别输出这三个有序链表的索引与元素的异或和。Note:给定序列是无序的，你需要首先得到一个有序的链表。 格式输入&emsp;&emsp;第一行两个整数N和M。&emsp;&emsp;第二行N个整数，代表第一组整数序列。&emsp;&emsp;第三行M个整数，代表第二组整数序列。 输出&emsp;&emsp;三行整数。分别代表第一组数、第二组数对应的有序链表与合并后有序链表的索引与元素的异或和。 样例输入点击右上角可直接复制。 123 03 1 2 输出123505 限制1s 算法描述&emsp;&emsp;使用已经封装的链表类和迭代器，增加方法getMax求链表元素的最大值，getMin求链表元素的最小值，binSort进行箱子排序，merge实现两个链表的归并。&emsp;&emsp;binSort的两个参数为链表元素的最大值和最小值，首先判断是否是空表，若是空表直接返回。若不是空表，根据min和max的值判断链表中元素的正负，分为三种情况，均&gt;=0，均&lt;=0，有正有负，对应相应的range（范围）和offset（偏移量），再进行箱子排序。在分配箱子时，将对应元素分配到theBin+offset的箱子中，收集箱子时，按照theBin从0到range进行收集。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct chainNode //节点类{ //数据成员 T element; chainNode&lt;T&gt;* next; //方法 chainNode() {} chainNode(const T&amp; element) { this-&gt;element=element; } chainNode(const T&amp; element,chainNode&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};template &lt;class T&gt;class chain //链表类{protected: chainNode&lt;T&gt;* firstNode; //指向链表第一个节点的指针 int listSize; //线性表的元素个数public: chain(); //构造函数 chain(const chain&lt;T&gt;&amp; theList); //复制构造函数 ~chain(); //析构函数 //方法 void insert(int idx,const T&amp; val); //在链表的idx位置插入元素val void erase(const T&amp; val); //删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 void reverse(); //原地逆置链表 int search(const T&amp; val) const; //查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 int output() const; //输出当前链表索引与元素的异或和 int size() const {return listSize;} //返回链表的元素个数 int getMax() const; //求链表中元素的最大值 int getMin() const; //求链表中元素的最小值 void binSort(int max,int min); //箱子排序 void merge(const chain&lt;T&gt;&amp; a,const chain&lt;T&gt;&amp; b);//将链表a,b归并到当前链表中 //迭代器 class iterator { protected: chainNode&lt;T&gt;* node; public: //用C++的typedef语句实现前向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(chainNode&lt;T&gt;* theNode=NULL) //构造函数 { node=theNode; } //解引用操作符 T&amp; operator* () const {return node-&gt;element;} T* operator-&gt; () const {return &amp;node-&gt;element;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { node=node-&gt;next; return *this; } iterator operator++ (int)//后++ { iterator old=*this; node=node-&gt;next; return old; } //相等检验 bool operator!= (const iterator&amp; right) const { return node!=right.node; } bool operator== (const iterator&amp; right) const { return node==right.node; } }; iterator begin() const { return iterator(firstNode); } iterator end() const { return iterator(NULL); }};template &lt;class T&gt;chain&lt;T&gt;::chain() //构造函数{ firstNode=NULL; listSize=0;}template &lt;class T&gt;chain&lt;T&gt;::chain(const chain&lt;T&gt;&amp; theList) //复制构造函数{ listSize=theList.listSize; //链表为空 if(listSize==0) { firstNode=NULL; return ; } //链表不为空 chainNode&lt;T&gt;* sourceNode=theList.firstNode; firstNode=new chainNode&lt;T&gt;(sourceNode-&gt;element);//复制theList的首元素 sourceNode=sourceNode-&gt;next; chainNode&lt;T&gt;* targetNode=firstNode; while(sourceNode!=NULL) //复制剩余元素 { targetNode-&gt;next=new chainNode&lt;T&gt;(sourceNode-&gt;element); targetNode=targetNode-&gt;next; sourceNode=sourceNode-&gt;next; } targetNode-&gt;next=NULL; //尾结点}template &lt;class T&gt;chain&lt;T&gt;::~chain() //析构函数{ while(firstNode!=NULL) { chainNode&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;void chain&lt;T&gt;::insert(int idx,const T&amp; val) //插入操作{//在链表的idx位置插入元素val if(idx==0)//在链表头插入 { firstNode=new chainNode&lt;T&gt;(val,firstNode); } else { //寻找前驱 chainNode&lt;T&gt;* p=firstNode; for(int i=0;i&lt;idx-1;i++) p=p-&gt;next; //在p之后插入 p-&gt;next=new chainNode&lt;T&gt;(val,p-&gt;next); } listSize++;}template &lt;class T&gt;void chain&lt;T&gt;::erase(const T&amp; val) //删除操作{//删除链表中的val元素。若链表中存在多个该元素，仅删除第一个；若该元素不存在，输出-1。 chainNode&lt;T&gt;* deleteNode; //要删除的节点 if(firstNode-&gt;element==val) //删除的是链表的首节点 { deleteNode=firstNode; firstNode=firstNode-&gt;next; } else //删除的不是链表的首节点 { chainNode&lt;T&gt;* previousNode=firstNode; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; previousNode=previousNode-&gt;next; } if(currentNode==NULL) //链表中不存在要删除的元素 { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return ; } else //链表中存在要删除的元素 { deleteNode=currentNode; previousNode-&gt;next=currentNode-&gt;next; } } listSize--; delete deleteNode;}template &lt;class T&gt;void chain&lt;T&gt;::reverse() //原地逆置{ if(listSize==1) //链表只有一个元素 return ; else { chainNode&lt;T&gt;* currentNode=firstNode; //当前节点 while(currentNode-&gt;next) //当前节点还有后继元素 { chainNode&lt;T&gt;* p=currentNode-&gt;next; //储存当前节点的后继元素 currentNode-&gt;next=p-&gt;next; //将p断开 p-&gt;next=firstNode; //将第一个节点连在p的后面 firstNode=p; //设置p为第一个节点 } }}template &lt;class T&gt;int chain&lt;T&gt;::search(const T&amp; val) const //查询操作{//查询链表中的val元素，并输出其索引。若链表中存在多个该元素，仅输出第一个的索引；若不存在该元素，输出-1。 chainNode&lt;T&gt;* currentNode=firstNode; int index=0; //当前节点的索引 while(currentNode!=NULL &amp;&amp; currentNode-&gt;element!=val) { currentNode=currentNode-&gt;next; //移向下一个节点 index++; } //确定是否找到元素 if(currentNode!=NULL) return index; else { return -1; }}template &lt;class T&gt;int chain&lt;T&gt;::output() const //输出当前链表索引与元素的异或和{ int res=0,index=0; for(iterator i=this-&gt;begin();i!=this-&gt;end();i++) //通过迭代器遍历链表 { res+=index^*i; index++; } return res;}template &lt;class T&gt;int chain&lt;T&gt;::getMax() const //求当前链表中元素的最大值{ if(listSize==0) //空表 return 0; int max=firstNode-&gt;element; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL) { if(currentNode-&gt;element&gt;max) max=currentNode-&gt;element; currentNode=currentNode-&gt;next; } return max;}template &lt;class T&gt;int chain&lt;T&gt;::getMin() const //求当前链表中元素的最小值{ if(listSize==0) //空表 return 0; int min=firstNode-&gt;element; chainNode&lt;T&gt;* currentNode=firstNode-&gt;next; while(currentNode!=NULL) { if(currentNode-&gt;element&lt;min) min=currentNode-&gt;element; currentNode=currentNode-&gt;next; } return min;}template &lt;class T&gt;void chain&lt;T&gt;::binSort(int max,int min) //箱子排序{ //空表 if(listSize==0) return ; //不是空表 int range=0,offset=0; //范围和偏移量 if(min&gt;=0) //链表所有元素均为非负整数 { range=max; offset=0; } else if(max&lt;=0) //链表所有元素均为非正整数 { range=-min; offset=-min; } else //链表元素有正有负 { range=max-min; offset=-min; } //创建并初始化箱子 chainNode&lt;T&gt; **bottom,**top; bottom=new chainNode&lt;T&gt;* [range+1]; top=new chainNode&lt;T&gt;* [range+1]; for(int i=0;i&lt;=range;i++) //初始化为空 bottom[i]=NULL; //把链表的节点分配到箱子 for(;firstNode!=NULL;firstNode=firstNode-&gt;next) {//把首节点firstNode加到箱子中 int theBin=firstNode-&gt;element; if(bottom[theBin+offset]==NULL) //箱子为空 bottom[theBin+offset]=top[theBin+offset]=firstNode; else //箱子不为空 { top[theBin+offset]-&gt;next=firstNode; top[theBin+offset]=firstNode; } } //把箱子中的节点收集到有序链表 chainNode&lt;T&gt; *y=NULL; for(int theBin=0;theBin&lt;=range;theBin++) { if(bottom[theBin]!=NULL) //箱子不空 { if(y==NULL) //收集的是第一个非空箱子 firstNode=bottom[theBin]; else //收集的不是第一个非空箱子 y-&gt;next=bottom[theBin]; y=top[theBin]; } } if(y!=NULL) //处理尾结点 y-&gt;next=NULL; delete [] bottom; delete [] top;}template &lt;class T&gt;void chain&lt;T&gt;::merge(const chain&lt;T&gt; &amp;a, const chain&lt;T&gt; &amp;b) //将链表a,b归并到当前链表中{ int index=0; iterator ia=a.begin(),ib=b.begin(); while(ia!=a.end() &amp;&amp; ib!=b.end()) { if(*ia&lt;*ib) //将*ia并入 { insert(index++,*ia); ia++; } else //将*ib并入 { insert(index++,*ib); ib++; } } //对a或b中剩余元素进行归并 while(ia!=a.end()) { insert(index++,*ia); ia++; } while(ib!=b.end()) { insert(index++,*ib); ib++; } listSize=a.size()+b.size();}int main(){ int n,m; //两个整数 int value; //读取初始链表的各个元素值 cin&gt;&gt;n&gt;&gt;m; chain&lt;int&gt; A,B,C; //创建对象 for(int i=0;i&lt;n;i++) //将数据插入链表A { cin&gt;&gt;value; A.insert(i,value); } for(int i=0;i&lt;m;i++) //将数据插入链表B { cin&gt;&gt;value; B.insert(i,value); } A.binSort(A.getMax(),A.getMin()); B.binSort(B.getMax(),B.getMin()); C.merge(A,B); cout&lt;&lt;A.output()&lt;&lt;endl; cout&lt;&lt;B.output()&lt;&lt;endl; cout&lt;&lt;C.output()&lt;&lt;endl; return 0;} 结果分析1.一般情况的箱子排序只需要参数range，条件是链表中的元素值均为非负整数，而题目中链表元素值包括负数，因此需要根据链表中的最大值和最小值确定range和offset。2.由箱子排序衍生出基数排序，所谓基数排序，是把数按照某种基数r分解为数字，然后对数字排序。例如，用基数10把十进制数928分解为9、2、8。利用箱子排序方法，从最低位开始依次到最高位，根据当前位的数字对数据进行排序。基数排序和箱子排序时间复杂度虽然相同，但使用基数排序极大地减少了程序的执行步数。单个的箱子排序实际上相当于r=1000的基数排序。基数排序的基数不同，总的执行步数也不同，根据实际数据确定基数减少执行步数。3.箱子排序和基数排序都是稳定的。4.箱子排序还有类外函数的实现方法，但执行了很多new和delete操作将节点从一个位置移动到另一个位置，虽然时间复杂度与成员函数相同，但效率比较低。","link":"/2020/10/14/DSA/DSA_4/"},{"title":"DSA：（六）栈","text":"&emsp;&emsp;数学表达式根据运算符和数字的相对位置可以分为前缀、中缀、后缀三种，前缀表达式又叫波兰表达式，后缀表达式又叫逆波兰表达式，这两种表达式都不含括号。中缀表达式可以转换为前缀表达式和后缀表达式，转换过程以及计算过程都需要用到栈结构。本文通过两种方法实现数学表达式的计算，方法一将中缀表达式转换为后缀表达式，然后进行计算，方法二直接对中缀表达式进行计算。 P1010:计算表达式题目描述 创建栈类，采用数组描述。 计算数学表达式的值。 输入数学表达式，输出表达式的计算结果。数学表达式由单个数字和运算符 + 、 - 、 * 、 / 、 ( 、 ) 构成，例如 2 + 3 * ( 4 + 5 )- 6 / 4。假定表达式输入格式合法。 格式输入第一行一个整数n(1&lt;=n&lt;=100)，代表表达式的个数。接下来n行，每行一个表达式，保证表达式内的数字为单个整数，表达式内各运算符和数字间没有空格，且表达式的长度不超过2000。 输出每行表达式输出一个浮点数，要求保留两位小数，保证输入表达式合法。 注意因为精度问题，请使用double存数据。 样例输入123431+6/1*7+2*1*4+9/1+2*0*9+9+7/(9*5)-1*6-0*8-7-9*2+6-(0-5-2*8-7-9*5*(6-5*5*2*6-2-7-5+6*7+6*9-1*0*0+3*0+2/1-6/6+5))0-4-1/6*(1-(6/7)-4+6+2+6*1)-1*7+2-8*2+0-(4+6-6*1+(3-8*6/4-6-5)*6/4/8+7-1*4/9*5)-0/6+1-0-2+7-2+6*4-3*6+2/8+6+1*6*25-3*9+5/1*5-9+1*8-6-8-4*1+5-2+9/3*2-2/5/(2-6)*2/7-9*0-2+4/6*6*7*8-8-8*6+8*9*(3+0*1/5/2*7*8+0-8*8-5+8/5*2-0) 输出123-9197.84-3.47-4362.57 限制1s, 65536KiB for each test case. 算法描述和实现方法一&emsp;&emsp;使用数组存储结构，封装栈类arrayStack，私有成员包括栈顶stackTop，栈容量arrayLength，元素数组stack。公有成员包括构造函数，析构函数，ADT方法包括判断栈是否为空，返回栈中元素个数，返回栈顶元素，删除栈顶元素，将元素压入栈顶。&emsp;&emsp;封装calculator类，私有成员包括一个double类型的栈，字符串s。公有成员包括输入，将中缀表达式转换为后缀表达式，处理后缀表达式，取2个操作数，对2个操作数进行运算，返回运算符优先级，输出结果，将char类型的数字转换为double类型，每个方法的具体思想如下： input：读入表达式（中缀）到私有成员s中。 change：将中缀表达式转换为后缀表达式。使用char类型的栈临时存储运算符。声明string类型的变量_s，用来临时存储后缀表达式。引入标记字符’#’，将其插入到运算符栈中，并规定其优先级为最低，这样做可以不用对栈空的情况进行特殊考虑。遍历表达式中每个字符，根据字符类型进行对应操作。字符串s遍历完毕后，如果栈顶元素不为标记字符（即栈非空），按顺序依次弹出栈中的元素，插入到_s的末端。 运算数：直接插入到_s的末端。 四则运算符：将该运算符与栈顶运算符优先级进行比较，如果优先级高于栈顶运算符，表示该部分运算还不能进行，将其压入栈；如果优先级低于或等于（优先级相同从左到右运算）栈顶运算符，表示前面部分的运算可以进行，将栈顶运算符弹出并插入到_s的末端，然后继续与新的栈顶运算符进行比较，直到优先级大于栈顶运算符（栈空的情况已经包含，因为设置标记字符的优先级为最低）,再将该运算符入栈。 左括号：直接压入栈，入栈后优先级降到最低，保证其它运算符正常入栈。 右括号：依次弹出栈顶运算符，并插入到_s的末端，直到遇到左括号。最后将左括号从栈顶删除。 operate：处理后缀表达式。遍历后缀表达式中的每个字符，如果是数字则入操作数栈，如果是操作符则取数进行运算。 getTwoNumbers：获取两个操作数。 calculate：对两个操作数进行运算。先使用getTwoNumbers方法获取两个操作数，然后根据运算符的类型进行对应的运算，将结果压入numberStack栈中。 order：返回运算符优先级。加减为1，乘除为2，左括号为0，右括号为3，标记符号为0。 output：输出最终结果。按照2位小数输出操作数栈的栈顶元素。 charToDouble：将char类型的数字字符转换为double类型。返回数字字符与’0’的差。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;template &lt;class T&gt;class arrayStack{private: int stackTop; //栈顶 int arrayLength; //栈容量 T* stack; //元素数组public: //构造函数、析构函数 arrayStack(int initialCapacity=10); ~arrayStack() {delete []stack;} //ADT方法 bool empty() const {return stackTop==-1;} int size() const {return stackTop+1;} T&amp; top(); void pop(); void push(const T&amp; theElement);};template &lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity){ arrayLength=initialCapacity; stack=new T[arrayLength]; stackTop=-1;}template &lt;class T&gt;T&amp; arrayStack&lt;T&gt;::top(){ return stack[stackTop];}template &lt;class T&gt;void arrayStack&lt;T&gt;::pop(){ stack[stackTop--].~T();}template &lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement){ if(stackTop==arrayLength-1) {//空间已满，容量加倍 T* newStack=new T[arrayLength*2]; arrayLength*=2; for(int i=0;i&lt;=stackTop;i++) newStack[i]=stack[i]; delete []stack; stack=newStack; } //在栈顶插入 stack[++stackTop]=theElement;}class calculator{private: arrayStack&lt;double&gt; numberStack; //操作数栈 string s; //存储中缀表达式和后缀表达式public: void input(); //读入中缀表达式 void change(); //将中缀表达式转换为后缀表达式 void operate(); //遍历后缀表达式中的每个字符，如果是数字则入栈，如果是操作符则取数进行运算 void getTwoNumbers(double &amp;num1,double &amp;num2); //获取两个操作数 void calculate(char op); //对两个操作数进行op运算 int order(char op); //运算符优先级 void output(); //输出最终结果 double charToDouble(char ch); //将char类型的数字字符转换为double类型};void calculator::input(){//读入中缀表达式 cin&gt;&gt;s;}void calculator::change(){//将中缀表达式转换为后缀表达式 arrayStack&lt;char&gt; operatorStack; //暂存运算符的栈 string _s; //暂存转换后的字符串 char ch; //当前的字符 operatorStack.push('#'); for(int i=0;i&lt;(int)s.size();i++) { ch=s.at(i); if(ch=='(') //左括号 { operatorStack.push(ch); } else if(ch==')') //右括号 { while(operatorStack.top()!='(') { _s.push_back(operatorStack.top()); operatorStack.pop(); } operatorStack.pop(); } else if(ch=='+'||ch=='-'||ch=='*'||ch=='/') //四则运算符 { char w=operatorStack.top(); if(order(w)&lt;order(ch)) { operatorStack.push(ch); } else { while(order(w)&gt;=order(ch)) { _s.push_back(w); operatorStack.pop(); w=operatorStack.top(); } operatorStack.push(ch); } } else//数字 { _s.push_back(ch); } } while(operatorStack.top()!='#') { _s.push_back(operatorStack.top()); operatorStack.pop(); } s=_s;}void calculator::getTwoNumbers(double &amp;num1,double &amp;num2){//获取两个操作数 num1=numberStack.top(); numberStack.pop(); num2=numberStack.top(); numberStack.pop();}void calculator::operate(){//遍历后缀表达式中的每个字符，如果是数字则入栈，如果是操作符则取数进行运算 for(int i=0;i&lt;(int)s.size();i++) { switch (s.at(i)) { case '-': case '+': case '*': case '/': calculate(s.at(i)); break; default: numberStack.push(charToDouble(s.at(i))); break; } }}void calculator::calculate(char op){//对两个操作数进行op运算 double number1,number2; getTwoNumbers(number1,number2); switch (op) { case '+':numberStack.push(number2+number1); break; case '-':numberStack.push(number2-number1); break; case '*':numberStack.push(number2*number1); break; case '/':numberStack.push(number2/number1); break; default: break; }}int calculator::order(char op){//运算符优先级 int val; if(op=='+'||op=='-') val=1; else if(op=='*'||op=='/') val=2; else if(op==')') val=3; else val=0; return val;}void calculator::output(){//输出最终结果 printf(&quot;%.2f\\n&quot;,numberStack.top());}double calculator::charToDouble(char ch){//将char类型的数字字符转换为double类型 double result=ch-'0'; return result;}int main(){ int n; //表达式个数 cin&gt;&gt;n; calculator c; for(int i=0;i&lt;n;i++) { c.input(); c.change(); c.operate(); c.output(); } return 0;} 方法二&emsp;&emsp;使用数组存储结构，封装栈类arrayStack，私有成员包括栈顶stackTop，栈容量arrayLength，元素数组stack。公有成员包括构造函数，析构函数，ADT方法包括判断栈是否为空，返回栈中元素个数，返回栈顶元素，删除栈顶元素，将元素压入栈顶。封装calculator类，私有成员包括一个double类型的操作数栈，一个char类型的运算符栈，字符串s。公有成员包括输入，遍历表达式进行相应处理，取2个操作数，对2个操作数进行运算，返回运算符优先级，输出结果，将char类型的数字转换为double类型，每个方法的具体思想如下： input：读入表达式到私有成员s中。 operate：遍历表达式中的每个字符，进行对应操作。operateStack栈存储运算符，首先将栈空的标记字符压入栈中，并规定其优先级为最低，这样做可以不用对栈空的情况进行特殊考虑。遍历表达式中每个字符，根据字符类型进行对应操作。 运算数：压入numberStack栈中。 四则运算符：将该运算符与操作符栈顶运算符优先级进行比较，如果优先级高于栈顶运算符，表示该部分运算还不能进行，将其压入栈；如果优先级低于或等于（优先级相同从左到右运算）栈顶运算符，表示前面部分的运算可以进行，取出栈顶运算符进行计算，完成计算后将栈顶运算符弹出，然后继续与新的栈顶运算符进行比较，直到优先级大于栈顶运算符（栈空的情况已经包含，因为设置标记字符的优先级为最低）,再将该运算符压入操作符栈。 左括号：直接压入栈，入栈后优先级降到最低，保证其它运算符正常入栈。 右括号：依次取栈顶运算符进行运算，直到遇到左括号为止。最后将左括号从栈顶删除。字符串s遍历完毕后，如果栈顶元素不为标记字符（即栈非空），依次取出栈顶运算符进行计算，计算结果压入numberStack中。 getTwoNumbers：获取两个操作数。 calculate：对两个操作数进行运算。先使用getTwoNumbers方法获取两个操作数，然后根据运算符的类型进行对应的运算，将结果压入numberStack栈中。 order：返回运算符优先级。加减为1，乘除为2，左括号为0，右括号为3，标记符号为0。 output：输出最终结果。按照2位小数输出操作数栈的栈顶元素。 charToDouble：将char类型的数字字符转换为double类型。返回数字字符与’0’的差。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;template &lt;class T&gt;class arrayStack{private: int stackTop; //栈顶 int arrayLength; //栈容量 T* stack; //元素数组public: //构造函数、析构函数 arrayStack(int initialCapacity=10); ~arrayStack() {delete []stack;} //ADT方法 bool empty() const {return stackTop==-1;} int size() const {return stackTop+1;} T&amp; top(); void pop(); void push(const T&amp; theElement);};template &lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity){ arrayLength=initialCapacity; stack=new T[arrayLength]; stackTop=-1;}template &lt;class T&gt;T&amp; arrayStack&lt;T&gt;::top(){ return stack[stackTop];}template &lt;class T&gt;void arrayStack&lt;T&gt;::pop(){ stack[stackTop--].~T();}template &lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement){ if(stackTop==arrayLength-1) {//空间已满，容量加倍 T* newStack=new T[arrayLength*2]; arrayLength*=2; for(int i=0;i&lt;=stackTop;i++) newStack[i]=stack[i]; delete []stack; stack=newStack; } //在栈顶插入 stack[++stackTop]=theElement;}class calculator{private: arrayStack&lt;double&gt; numberStack; //操作数栈 arrayStack&lt;char&gt; operatorStack; //操作符栈 string s; //存储表达式public: void input(); //读入表达式 void operate(); //遍历表达式中的每个字符，进行相应处理 void getTwoNumbers(double &amp;num1,double &amp;num2); //获取两个操作数 void calculate(char op); //对两个操作数进行op运算 int order(char op); //运算符优先级 void output(); //输出最终结果 double charToDouble(char ch); //将char类型的数字字符转换为double类型};void calculator::input(){//读入表达式 cin&gt;&gt;s;}void calculator::getTwoNumbers(double &amp;num1,double &amp;num2){//获取两个操作数 num1=numberStack.top(); numberStack.pop(); num2=numberStack.top(); numberStack.pop();}void calculator::operate(){//遍历表达式中的每个字符，进行对应操作 operatorStack.push('#'); //设置栈空的标记字符，优先级设为最低 for(int i=0;i&lt;(int)s.size();i++) //遍历每个字符 { char ch=s.at(i); //当前字符 if(ch&gt;='0' &amp;&amp; ch&lt;='9') //数字 numberStack.push(charToDouble(ch)); //转换类型后入操作数栈 else //运算符 { if(ch=='(') //左括号 operatorStack.push(ch); //压入操作符栈 else if(ch==')') //右括号 { while(operatorStack.top()!='(') //进行计算直到遇到左括号 { calculate(operatorStack.top()); operatorStack.pop(); } operatorStack.pop(); //删除左括号 } else //四则运算符 { if(order(ch)&gt;order(operatorStack.top())) //当前运算符优先级高于栈顶运算符优先级 operatorStack.push(ch); else //当前运算符优先级低于或等于栈顶运算符优先级 { while(order(ch)&lt;=order(operatorStack.top())) {//进行计算 calculate(operatorStack.top()); operatorStack.pop(); } operatorStack.push(ch); //当前运算符压入操作符栈 } } } } //栈不为空 while(operatorStack.top()!='#') { char op=operatorStack.top(); operatorStack.pop(); calculate(op); }}void calculator::calculate(char op){//对两个操作数进行op运算 double number1,number2; getTwoNumbers(number1,number2); switch (op) { case '+':numberStack.push(number2+number1); break; case '-':numberStack.push(number2-number1); break; case '*':numberStack.push(number2*number1); break; case '/':numberStack.push(number2/number1); break; default: break; }}int calculator::order(char op){//运算符优先级 int val; if(op=='+'||op=='-') val=1; else if(op=='*'||op=='/') val=2; else if(op==')') val=3; else val=0; return val;}void calculator::output(){//输出最终结果 printf(&quot;%.2f\\n&quot;,numberStack.top());}double calculator::charToDouble(char ch){//将char类型的数字字符转换为double类型 double result=ch-'0'; return result;}int main(){ int n; //表达式个数 cin&gt;&gt;n; calculator c; for(int i=0;i&lt;n;i++) { c.input(); c.operate(); c.output(); } return 0;} 结果分析1.在操作符栈中压入标记字符，并将其优先级设置为最低，在后续的判断中不用考虑栈空的情况，减少比较次数，提高程序性能。2.逆波兰表达式求值是递归的一道经典问题，也可采用递归进行求解。","link":"/2020/11/04/DSA/DSA_6/"},{"title":"DSA：（八）散列表","text":"&emsp;&emsp;散列表（哈希表）有两种实现方法，一种是线性探查，一种是链表散列。散列常作为字典的表示方法，通过哈希函数把字典的数对映射到散列表的具体位置，散列表的每一个位置叫做一个桶。散列表的最坏性能与线性表相同，因此性能很好，但是缺点是溢出后无法对散列表进行扩容（只能重新建立一个新的散列表）。所以在实际应用过程中散列表一般会开的比较大，保证不会溢出，同时需要选择一个好的除数减少冲突。本文的两个问题在实现过程中通过关键字模拟散列表的操作，即散列表每个位置的元素是关键字而不是数对。 P1012:线性开型寻址描述给定散列函数的除数D和操作数m，输出每次操作后的状态。有以下三种操作：1.插入x，若散列表已存在x，输出“Existed”，否则插入x到散列表中，输出所在的下标。2.查询x，若散列表不含有x，输出“-1”，否则输出x对应下标。3.删除x，若散列表不含有x，输出“Not Found”，否则输出删除x过程中移动元素的个数。 要求使用线性开型寻址实现 格式输入第一行两个整数D，m。分别代表散列函数的除数D和操作数m。接下来m行，每行两个整数opt和x，分别代表操作类型和操作数。若opt为0，代表插入x。若opt为1，代表查询x。若opt为2，代表删除x。 输出按要求输出。 样例样例1输入123456789101112137 121 210 10 130 50 230 260 331 331 331 131 51 1 输出123456789101112-116520333651 样例2输入1234567891011121314151617181920212223242526272829303120 300 840 150 542 152 841 542 540 891 890 130 482 890 600 241 130 61 240 312 602 480 490 91 61 130 332 490 601 62 91 60 输出123456789101112131415161718192021222324252627282930415140014099138004136411009106131410600 限制1s, 64MB for each test case. 算法描述&emsp;&emsp;使用数组存储结构，封装散列表类hashTable，protected成员包括存储散列表的数组table，除数divisor，散列表的大小dSize，查询关键字的search方法，public成员包括构造函数，析构函数，empty方法，size方法，寻找关键字的find方法，插入关键字的insert方法，删除关键字的erase方法。 search：搜索散列表，查询关键字theKey，如果存在关键字返回其位置，否则返回该关键字可以插入的位置。从起始桶开始，判断table[i]是否为空或者指向的元素是否为theKey。 find：调用search方法搜索散列表得到位置b，通过table[b]是否为空或者指向的元素是否为theKey判断是否匹配，若不匹配输出-1，返回NULL，若匹配输出关键字在散列表的位置b，返回table[b]。 insert：调用search方法搜索散列表得到位置b，如果table[b]为NULL，插入该关键字，输出插入位置b，否则存在匹配的关键字（因为题目保证散列表不会溢出），输出“Existed”。 erase：调用search方法搜索散列表得到位置b，起始桶homeBucket保存b的位置，如果table[b]=NULL，则不存在该关键字，输出“Not Found”然后返回。否则存在该关键字，首先释放内存，将散列表的长度-1，moveTimes记录元素移动次数，然后进入外层循环，将位置b置空，使用gap记录删除的关键字的位置。进入内层循环，b移向下一个位置，如果table[b]为空或者b=homeBucket(即已经遍历散列表)，则不需要再判断元素是否需要移动，输出移动次数然后返回。否则需要判断元素是否需要移动，通过pos记录散列表当前位置的关键字的起始桶位置，不需要移动的条件是pos在gap和b之间，考虑有环和没有环的情况，通过三个条件给出限制，否则需要进行移动，跳出内层循环，用b填充gap，移动次数+1，然后继续进行下去，直到满足返回的条件。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class hashTable{protected: int search(const T&amp; theKey) const; //搜索散列表，查询关键字theKey，如果有存在该关键字，返回其位置，否则返回该关键字可以插入的位置 T** table; //散列表 int divisor; //散列函数的除数 int dSize; //散列表的大小public: hashTable(int theDivisor=11); //构造函数 ~hashTable() {delete []table;} //析构函数 bool empty() const {return dSize==0;} int size() const {return dSize;} T* find(const T&amp; theKey) const; //返回关键字theKey的指针，若不存在该关键字，则返回NULL void insert(const T&amp; theKey); //在散列表中插入关键字theKey，若存在相同的关键字则覆盖 void erase(const T&amp; theKey); //在散列表中删除关键字theKey，若不存在输出错误信息};template &lt;class T&gt;hashTable&lt;T&gt;::hashTable(int theDivisor){ divisor=theDivisor; dSize=0; //分配和初始化散列表数组 table=new T*[divisor]; for(int i=0;i&lt;divisor;i++) //将所有桶置空 table[i]=NULL;}template &lt;class T&gt;int hashTable&lt;T&gt;::search(const T&amp; theKey) const{//搜索散列表，查询关键字theKey //如果有存在该关键字，返回其位置，否则返回该关键字可以插入的位置 int i=theKey % divisor; //起始桶 int j=i; //从起始桶开始 do{ if(table[j]==NULL || *table[j]==theKey) return j; j=(j+1)%divisor; //下一个桶 }while(j!=i); return j;//表已经满}template &lt;class T&gt;T* hashTable&lt;T&gt;::find(const T&amp; theKey) const{//返回关键字theKey的指针，若不存在该关键字，则返回NULL //搜索散列表 int b=search(theKey); //判断table[b]是否匹配 if(table[b]==NULL || *table[b]!=theKey) //不匹配 { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; return NULL; } //匹配 cout&lt;&lt;b&lt;&lt;endl; return table[b];}template &lt;class T&gt;void hashTable&lt;T&gt;::insert(const T&amp; theKey){//在散列表中插入关键字theKey，若存在相同的关键字则覆盖 int b=search(theKey); //检查匹配的关键字是否存在 //没有匹配的关键字，且表不满，则插入该关键字 if(table[b]==NULL) { table[b]=new T(theKey); dSize++; cout&lt;&lt;b&lt;&lt;endl; } else //存在匹配的关键字 cout&lt;&lt;&quot;Existed&quot;&lt;&lt;endl;}template &lt;class T&gt;void hashTable&lt;T&gt;::erase(const T&amp; theKey){//在散列表中删除关键字theKey //若不存在输出错误信息 int b=search(theKey); int homeBucket=b; if(table[b]==NULL) //不存在该关键字 { cout&lt;&lt;&quot;Not Found&quot;&lt;&lt;endl; return ; } //存在该关键字 delete table[b]; //释放内存 dSize--; //散列表长度-1 int moveTimes=0; //元素移动次数 for(;;) { table[b]=NULL; //将散列表的位置b置空 int gap=b; //记录删除的关键字的位置 for(;;) { b=(b+1)%divisor; //b的下一个位置 if(table[b]==NULL||b==homeBucket) //不需要再进行移动，直接返回 { cout&lt;&lt;moveTimes&lt;&lt;endl; return ; } int pos=*table[b]%divisor; //当前关键字在散列表中的原始映射位置 //不受散列表中删除关键字的影响 //三个条件都限制了pos要在gap和b之间 if(gap&lt;pos &amp;&amp; pos&lt;=b) continue; if(gap&gt;b &amp;&amp; gap&lt;pos) continue; if(gap&gt;b &amp;&amp; pos&lt;=b) continue; //受到影响，跳出循环 break; } table[gap]=table[b]; //用b填充gap moveTimes++; }}int main(){ int D,m,instruction,x; cin&gt;&gt;D&gt;&gt;m; hashTable&lt;int&gt; H(D); for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch(instruction) { case 0: cin&gt;&gt;x; H.insert(x); break; case 1: cin&gt;&gt;x; H.find(x); break; case 2: cin&gt;&gt;x; H.erase(x); break; } } return 0;} P1013:链表散列描述给定散列函数的除数D和操作数m，输出每次操作后的状态。有以下三种操作：1.插入x，若散列表已存在x，输出”Existed”。2.查询x，若散列表不含有x，输出”Not Found”，否则输出x所在的链表长度。3.删除x，若散列表不含有x，输出”Delete Failed”，否则输出x所在链表删除x后的长度。 要求使用链表散列方式 格式输入第一行两个整数D(1&lt;=D&lt;=3000)和m(1&lt;=m&lt;=3000)，其中D为散列函数的除数，m为操作数。接下来的m行，每行两个整数opt和x，分别代表操作类型和操作数。若opt为0，则代表向散列表中插入x；若opt为1，代表查询散列表中x是否存在；若opt为2，(如果散列表中含有x)，删除x。数据保证散列表不会溢出。 输出按要求输出。 样例样例1输入123456789101112137 121 210 10 130 50 230 260 331 331 331 131 51 1 输出123456Not Found33131 样例2输入123456789101112131415167 152 100 100 102 101 100 101 100 170 20 160 112 22 101 111 17 输出123456789Delete FailedExisted0Not Found11111 限制1s, 64MB for each test case. 数据范围对于前60%的数据，只包含插入和查询操作。对于后40%的数据，包含插入、查询与删除操作。 算法描述&emsp;&emsp;使用链式存储结构，封装散列表类hashChains，protected成员包括有序链表数组table，散列函数的除数divisor，散列表的大小dSize，public成员包括构造函数，析构函数，empty方法，size方法，查询关键字的find方法，插入关键字的insert方法，删除关键字的erase方法。操作主要通过sortedChain类的方法来实现。 find：首先通过关键字确定起始桶的位置homeBucket，然后在起始桶中调用sortedChain类的find方法，根据返回值是否为空判断是否存在匹配的关键字，若不存在，输出“Not Found”，若存在，通过调用table[homeBucket]的size方法输出关键字所在链表的长度。 insert：首先通过关键字确定起始桶的位置homeBucket，homeSize表示homeBucket桶在插入前的链表长度，调用table[homeBucket]的insert方法，进行插入操作，若已经存在相同的关键字，输出“Existed”，否则进行关键字的插入，根据homeSize和插入后table[homeBucket]长度的比较，判断是否进行了插入（排除相同关键字的情况），对散列表的大小进行相应增加。 erase：首先通过关键字确定起始桶的位置homeBucket，然后调用table[homeBucket]的erase方法，若不存在关键字，输出“Delete Failed”，若存在进行相应删除操作，输出删除该关键字后的链表长度。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;struct node{ T element; node&lt;T&gt;* next; node() {} node(const T&amp; element) { this-&gt;element=element; } node(const T&amp; element,node&lt;T&gt;* next) { this-&gt;element=element; this-&gt;next=next; }};template &lt;class T&gt;class sortedChain{protected: node&lt;T&gt;* firstNode; //指向有序链表第一个节点的指针 int dSize; //有序链表的长度public: sortedChain(int initialCapacity=10); ~sortedChain(); bool empty() const {return dSize==0;} int size() const {return dSize;} T* find(const T&amp; theKey) const; //查询关键字theKey void insert(const T&amp; theKey); //插入关键字theKey，若已经存在关键字，输出Existed void erase(const T&amp; theKey); //删除关键字theKey，若不存在该关键字输出Delete Failed};template &lt;class T&gt;sortedChain&lt;T&gt;::sortedChain(int initialCapacity){ firstNode=NULL; dSize=0;}template &lt;class T&gt;sortedChain&lt;T&gt;::~sortedChain&lt;T&gt;(){ while (firstNode!=NULL) { node&lt;T&gt;* nextNode=firstNode-&gt;next; delete firstNode; firstNode=nextNode; }}template &lt;class T&gt;T* sortedChain&lt;T&gt;::find(const T &amp;theKey) const {//查询关键字theKey，若不存在返回NULL，若存在返回节点数据域的地址 node&lt;T&gt;* currentNode=firstNode; while(currentNode!=NULL &amp;&amp; currentNode-&gt;element&lt;theKey) currentNode=currentNode-&gt;next; if(currentNode!=NULL &amp;&amp; currentNode-&gt;element==theKey) return &amp;currentNode-&gt;element; return NULL;}template &lt;class T&gt;void sortedChain&lt;T&gt;::insert(const T &amp;theKey){//插入关键字theKey，若已经存在关键字，输出Existed node&lt;T&gt;* p=firstNode; node&lt;T&gt;* tp=NULL; while(p!=NULL &amp;&amp; p-&gt;element&lt;theKey) { tp=p; p=p-&gt;next; } if(p!=NULL &amp;&amp; p-&gt;element==theKey) { cout&lt;&lt;&quot;Existed&quot;&lt;&lt;endl; return ; } node&lt;T&gt;* newNode=new node&lt;T&gt;(theKey,p); if(tp==NULL) //插在首节点 firstNode=newNode; else tp-&gt;next=newNode; dSize++;}template &lt;class T&gt;void sortedChain&lt;T&gt;::erase(const T &amp;theKey){//删除关键字theKey，若不存在该关键字输出Delete Failed node&lt;T&gt;* p=firstNode; node&lt;T&gt;* tp=NULL; while(p!=NULL &amp;&amp; p-&gt;element&lt;theKey) { tp=p; p=p-&gt;next; } if((p!=NULL &amp;&amp; p-&gt;element&gt;theKey) || p==NULL) { cout&lt;&lt;&quot;Delete Failed&quot;&lt;&lt;endl; return ; } if(p!=NULL &amp;&amp; p-&gt;element==theKey) { if(tp==NULL) firstNode=p-&gt;next; else tp-&gt;next=p-&gt;next; delete p; dSize--; cout&lt;&lt;dSize&lt;&lt;endl; }}template &lt;class T&gt;class hashChains{protected: sortedChain&lt;T&gt;* table; //链表数组 int divisor; //散列函数的除数 int dSize; //散列表的大小public: hashChains(int theDivisor=11); ~hashChains() {delete []table;} bool empty() const {return dSize==0;} int size() const {return dSize;} void find(const T&amp; theKey) const; //查询关键字theKey，若不存在该关键字，输出Not Found，若存在输出所在链表的长度 void insert(const T&amp; theKey); //在散列表中插入关键字theKey，若存在相同的关键字则覆盖 void erase(const T&amp; theKey); //在散列表中删除关键字theKey，若不存在输出错误信息};template &lt;class T&gt;hashChains&lt;T&gt;::hashChains(int theDivisor){ divisor=theDivisor; dSize=0; table=new sortedChain&lt;T&gt;[divisor];}template &lt;class T&gt;void hashChains&lt;T&gt;::find(const T&amp; theKey) const{//返回关键字theKey匹配的数对的指针 int homeBucket=theKey % divisor; T* temp=table[homeBucket].find(theKey); if(temp==NULL) cout&lt;&lt;&quot;Not Found&quot;&lt;&lt;endl; else cout&lt;&lt;table[homeBucket].size()&lt;&lt;endl;}template &lt;class T&gt;void hashChains&lt;T&gt;::insert(const T&amp; theKey){//在字典中插入一个数对thePair，若存在关键字相同的数对，则覆盖 int homeBucket=theKey % divisor; int homeSize=table[homeBucket].size(); table[homeBucket].insert(theKey); if(table[homeBucket].size()&gt;homeSize) dSize++;}template &lt;class T&gt;void hashChains&lt;T&gt;::erase(const T&amp; theKey){//删除关键字为theKey的数对 int homeBucket=theKey % divisor; table[homeBucket].erase(theKey);}int main(){ int D,m,instruction,x; cin&gt;&gt;D&gt;&gt;m; hashChains&lt;int&gt; H(D); for(int i=0;i&lt;m;i++) { cin&gt;&gt;instruction; switch(instruction) { case 0: cin&gt;&gt;x; H.insert(x); break; case 1: cin&gt;&gt;x; H.find(x); break; case 2: cin&gt;&gt;x; H.erase(x); break; } } return 0;} 结果分析1.线性探查的删除操作的核心是在删除一个元素后，判断散列剩余的元素要不要进行移动，如果需要移动，移动到哪个位置。在实现中，gap表示需要进行填充的位置，如果不进行填充，会破坏散列表的组织，影响后序的搜索等操作，不需要进行移动的元素应该满足其起始桶位置在gap和b之间，这样在线性探查的过程中，不会遇到gap，不影响该元素的搜索，所以这样的元素不需要进行移动。2.线性探查的删除操作也可以为每个桶增加一个neverUsed域，用来标识这个桶是否曾经存有元素然后该元素被删除，保证在探查过程中不会受到删除的影响。3.散列在最坏情况下的复杂度与线性表在最坏情况下的复杂度相同，使用链表时的平均性能优于线性探查。4.数对的表示可以通过pair&lt;const K,E&gt;，pair.first为关键字，pair.second为元素值。","link":"/2020/11/22/DSA/DSA_8/"},{"title":"DSA：（九）二叉树操作","text":"&emsp;&emsp;树型结构适合表示层次关系。本文通过链表实现二叉树的操作，包括前序遍历、中序遍历、后序遍历、层次遍历、计算节点数目和高度，以及通过前序序列和中序序列构造出二叉树。 P1014:二叉树基础描述创建二叉树类。二叉树的存储结构使用链表。提供操作:前序遍历、中序遍历、后序遍历、层次遍历、计算二叉树结点数目、计算二叉树高度。 格式输入第一行为一个数字n(10&lt;=n&lt;=100000)，表示这棵树有n个节点，编号为1 ~ n。之后n行每行两个数字，第i行的两个数字a、b表示编号为i的节点的左孩子节点为a，右孩子节点为b，-1表示该位置没有节点。保证数据有效，根节点为1。 输出第一行，n个数字，表示该树的层次遍历。第二行，n个数字，第i个数字表示以i节点为根的子树的节点数目。第三行，n个数字，第i个数字表示以i节点为根的子树的高度。 样例样例1输入12345652 34 5-1 -1-1 -1-1 -1 输出1231 2 3 4 55 3 1 1 13 2 1 1 1 样例2输入12345653 2-1 -14 5-1 -1-1 -1 输出1231 3 2 4 55 1 3 1 13 1 2 1 1 样例3输入1234567891011102 -14 36 -15 89 7-1 -1-1 -1-1 -110 -1-1 -1 输出1231 2 4 3 5 8 6 9 7 10 10 9 2 6 4 1 1 1 2 1 6 5 2 4 3 1 1 1 2 1 Hint请仔细读题，注意建树过程。 算法描述&emsp;&emsp;封装二叉树类linkedBinaryTree，二叉树的存储结构使用链表，每个节点包括元素值element，左孩子leftChild，右孩子rightChild。节点类的构造函数有三个，默认构造函数，通过theElement构造，通过theElement，theLeftChild，theRightChild构造。二叉树类中，非静态的私有成员包括根节点root，树的节点个数treeSize，求以t为根节点的子树的高度height方法，求以t为根节点的子树的节点个数nodeNumber方法，静态的私有成员包括访问函数visit，前序遍历preOrder，中序遍历inOrder，后序遍历postOrder，删除t指向的节点dispose方法。公有成员包括构造函数，析构函数，empty方法，size方法，前序遍历，中序遍历，后序遍历，层次遍历，删除二叉树的erase方法，求二叉树的节点个数和高度，初始化二叉树initialize方法，输出以二叉树所有节点为根节点的子树的高度和节点个数。前序遍历按照根、左、右的顺序访问二叉树的节点，中序遍历按照左、根、右的顺序访问二叉树的节点，后序遍历按照左、右、跟的顺序访问二叉树的节点。三种遍历方法都用递归实现。层次遍历利用队列的“先进先出”实现。erase：删除整颗二叉树。通过后序遍历，对访问到的每一个节点调用dispose方法执行删除操作，最后将root置空，treeSize置零。已知根节点求树的节点个数和高度，都用递归实现。求节点个数时，先求出左右子树的节点个数，相加再加一得到树的节点个数。求高度时，先求出左右子树的高度，二者的较大值加一得到树的高度。初始化二叉树，首先将每个节点的左孩子和右孩子分别存入两个数组，然后利用层次遍历，对遍历到的当前的元素，根据左孩子和右孩子，构造相应的节点。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}template &lt;class T&gt;struct binaryTreeNode //二叉树节点类{ T element; binaryTreeNode&lt;T&gt; *leftChild, *rightChild; //三个构造函数 binaryTreeNode() {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement):element(theElement) {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement,binaryTreeNode&lt;T&gt;* theLeftChild,binaryTreeNode&lt;T&gt;* theRightChild):element(theElement) { leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class linkedBinaryTree{private: binaryTreeNode&lt;T&gt; *root; //根节点指针 int treeSize; //树的节点个数 static void (*visit)(binaryTreeNode&lt;T&gt; *); //访问函数 static void preOrder(binaryTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(binaryTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(binaryTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(binaryTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 int height(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的高度 int nodeNumber(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的节点个数public: linkedBinaryTree() {root=NULL; treeSize=0;} ~linkedBinaryTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void levelOrder(void(*)(binaryTreeNode&lt;T&gt;*)); //层次遍历 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } int Height() const {return height(root);} //计算二叉树的高度 int NodeNumber() const {return nodeNumber(root);} //计算二叉树的节点个数 void initialize(int num); //二叉树的初始化 void subtreeNodeNumber() const; //输出二叉树中所有节点为根的子树的节点个数 void subtreeHeight() const; //输出二叉树中所有节点为根的子树的高度};template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt;*)=NULL; //类的静态成员的初始化template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::preOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { linkedBinaryTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::inOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); linkedBinaryTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::postOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); linkedBinaryTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::height(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int hl=height(t-&gt;leftChild); int hr=height(t-&gt;rightChild); if(hl&gt;hr) return ++hl; else return ++hr;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::nodeNumber(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int nl=nodeNumber(t-&gt;leftChild); int nr=nodeNumber(t-&gt;rightChild); return nl+nr+1;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::levelOrder(void (*theVisit)(binaryTreeNode&lt;T&gt; *)){ binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while (t!=NULL) { theVisit(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else return ; q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::initialize(int num){//二叉树的初始化 //这棵树有num个节点，编号为1~num，根节点为1 //读入编号为i的节点的左孩子a，右孩子b，-1表示该位置没有节点 root=new binaryTreeNode&lt;T&gt;(1); treeSize=num; int *left=new int[num+1]; //左孩子 int *right=new int[num+1]; //右孩子 binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; for(int i=1;i&lt;=num;i++) cin&gt;&gt;left[i]&gt;&gt;right[i]; int cur=t-&gt;element; //当前节点的element值 //利用层次遍历进行初始化 while (t!=NULL) { if(left[cur]!=-1) t-&gt;leftChild=new binaryTreeNode&lt;T&gt;(left[cur]); if(right[cur]!=-1) t-&gt;rightChild=new binaryTreeNode&lt;T&gt;(right[cur]); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //初始化完成 { delete []left; delete []right; return ; } q.pop(); cur=t-&gt;element; }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeNodeNumber() const{//输出二叉树中所有节点为根的子树的节点个数 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的节点个数 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=nodeNumber(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeHeight() const{//输出二叉树中所有节点为根的子树的高度 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的高度 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=height(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void output(binaryTreeNode&lt;T&gt;* t){//输出节点的element值 cout&lt;&lt;t-&gt;element&lt;&lt;&quot; &quot;;}int main(){ int n; linkedBinaryTree&lt;int&gt; BT; cin&gt;&gt;n; BT.initialize(n); BT.levelOrder(output); cout&lt;&lt;endl; BT.subtreeNodeNumber(); cout&lt;&lt;endl; BT.subtreeHeight(); cout&lt;&lt;endl; return 0;} P1015:二叉树遍历描述接收二叉树前序序列和中序序列(各元素各不相同)，输出该二叉树的后序序列。 格式输入输入有三行：第一行为数字n。第二行有n个数字，表示二叉树的前序遍历。第三行有n个数字，表示二叉树的中序遍历。 输出输出一行，表示该二叉树的后序遍历序列。 样例输入12351 2 4 5 34 2 5 1 3 输出14 5 2 3 1 算法描述&emsp;&emsp;在二叉树类linkedBinaryTree的基础上增加方法buildTree和update。buildTree的参数为前序序列pre，中序序列in，序列长度len，返回构造出的二叉树的根节点。buildTree通过递归实现，根据前序序列中的pre[0]，在中序序列中查找pre[0]的位置，根据pre[0]将中序序列分为左、根、右三部分，对于每一个部分，按照相同的方法进行构造，根据递归调用即可。update根据buildTree的返回值和序列长度，更新私有成员root和treeSize。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class arrayQueue{private: int queueFront; //队列首元素的下一个位置（逆时针方向） int queueBack; //队列最后一个元素的位置 int arrayLength; //数组大小 T* queue; //存储队列的数组public: arrayQueue(int initialCapacity=10); ~arrayQueue() {delete []queue;} bool empty() const {return queueFront==queueBack;} int size() const {return (arrayLength+queueBack-queueFront)%arrayLength;} T&amp; front() const; //返回队首元素 T&amp; back() const; //返回队尾元素 void pop(); //删除队首元素 void push(const T&amp; theElement); //元素插入到队尾};template &lt;class T&gt;arrayQueue&lt;T&gt;::arrayQueue(int initialCapacity){ arrayLength=initialCapacity; queue=new T[arrayLength]; queueFront=queueBack=0;}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::front() const{//返回队首元素 return queue[(queueFront+1)%arrayLength];}template &lt;class T&gt;T&amp; arrayQueue&lt;T&gt;::back() const{//返回队尾元素 return queue[queueBack];}template &lt;class T&gt;void arrayQueue&lt;T&gt;::pop(){//删除队首元素 queueFront=(queueFront+1)%arrayLength; queue[queueFront].~T();}template &lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement){//元素插入到队尾 //如果插入一个元素后队列满，需要扩充容量 if((queueBack+1)%arrayLength==queueFront) { T* newQueue=new T[2*arrayLength]; int start=(queueFront+1)%arrayLength; //复制元素 if(start&lt;2) //原队列中没有形成环 copy(queue+start,queue+start+arrayLength-1,newQueue); else //原队列中形成环 { copy(queue+start,queue+arrayLength,newQueue); copy(queue,queue+queueBack+1,newQueue+arrayLength-start); } queueFront=2*arrayLength-1; queueBack=arrayLength-2; arrayLength*=2; delete []queue; queue=newQueue; } queueBack=(queueBack+1)%arrayLength; queue[queueBack]=theElement;}template &lt;class T&gt;struct binaryTreeNode //二叉树节点类{ T element; binaryTreeNode&lt;T&gt; *leftChild, *rightChild; //三个构造函数 binaryTreeNode() {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement):element(theElement) {leftChild=rightChild=NULL;} binaryTreeNode(const T&amp; theElement,binaryTreeNode&lt;T&gt;* theLeftChild,binaryTreeNode&lt;T&gt;* theRightChild):element(theElement) { leftChild=theLeftChild; rightChild=theRightChild; }};template &lt;class T&gt;class linkedBinaryTree{private: binaryTreeNode&lt;T&gt; *root; //根节点指针 int treeSize; //树的节点个数 static void (*visit)(binaryTreeNode&lt;T&gt; *); //访问函数 static void preOrder(binaryTreeNode&lt;T&gt; *t); //前序遍历 static void inOrder(binaryTreeNode&lt;T&gt; *t); //中序遍历 static void postOrder(binaryTreeNode&lt;T&gt; *t); //后序遍历 static void dispose(binaryTreeNode&lt;T&gt; *t) {delete t;} //删除t指向的节点 static void output(binaryTreeNode&lt;T&gt; *t) {cout&lt;&lt;t-&gt;element&lt;&lt;&quot; &quot;;} //输出节点t的element值 int height(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的高度 int nodeNumber(binaryTreeNode&lt;T&gt; *t) const; //计算以t为根节点的子树的节点个数public: linkedBinaryTree() {root=NULL; treeSize=0;} ~linkedBinaryTree() {erase();} bool empty() const {return treeSize==0;} int size() const {return treeSize;} void preOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; preOrder(root); } void inOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; inOrder(root); } void postOrder(void(*theVisit)(binaryTreeNode&lt;T&gt;*)) { visit=theVisit; postOrder(root); } void postOrderOutput() //后序输出序列 {postOrder(output);cout&lt;&lt;endl;} void levelOrder(void(*)(binaryTreeNode&lt;T&gt;*)); //层次遍历 void erase() //删除二叉树 { postOrder(dispose); root=NULL; treeSize=0; } int Height() const {return height(root);} //计算二叉树的高度 int NodeNumber() const {return nodeNumber(root);} //计算二叉树的节点个数 void initialize(int num); //二叉树的初始化 void subtreeNodeNumber() const; //输出二叉树中所有节点为根的子树的节点个数 void subtreeHeight() const; //输出二叉树中所有节点为根的子树的高度 binaryTreeNode&lt;T&gt;* buildTree(T* pre,T* in,int len); //通过前序序列pre和中序序列in构造一颗二叉树,len表示序列长度 void update(T* pre,T* in,int len); //将构造的二叉树放到对象中，即更新root和treeSize};template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt; *)=NULL; //类的静态成员的初始化template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::preOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { linkedBinaryTree&lt;T&gt;::visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::inOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { inOrder(t-&gt;leftChild); linkedBinaryTree&lt;T&gt;::visit(t); inOrder(t-&gt;rightChild); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::postOrder(binaryTreeNode&lt;T&gt; *t){ if(t!=NULL) { postOrder(t-&gt;leftChild); postOrder(t-&gt;rightChild); linkedBinaryTree&lt;T&gt;::visit(t); }}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::height(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int hl=height(t-&gt;leftChild); int hr=height(t-&gt;rightChild); if(hl&gt;hr) return ++hl; else return ++hr;}template &lt;class T&gt;int linkedBinaryTree&lt;T&gt;::nodeNumber(binaryTreeNode&lt;T&gt; *t) const{ if(t==NULL) return 0; int nl=nodeNumber(t-&gt;leftChild); int nr=nodeNumber(t-&gt;rightChild); return nl+nr+1;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::levelOrder(void (*theVisit)(binaryTreeNode&lt;T&gt; *)){ binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while (t!=NULL) { theVisit(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else return ; q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::initialize(int num){//二叉树的初始化 //这棵树有num个节点，编号为1~num，根节点为1 //读入编号为i的节点的左孩子a，右孩子b，-1表示该位置没有节点 root=new binaryTreeNode&lt;T&gt;(1); treeSize=num; int *left=new int[num+1]; //左孩子 int *right=new int[num+1]; //右孩子 binaryTreeNode&lt;T&gt; *t=root; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; for(int i=1;i&lt;=num;i++) cin&gt;&gt;left[i]&gt;&gt;right[i]; int cur=t-&gt;element; //当前节点的element值 //利用层次遍历进行初始化 while (t!=NULL) { if(left[cur]!=-1) t-&gt;leftChild=new binaryTreeNode&lt;T&gt;(left[cur]); if(right[cur]!=-1) t-&gt;rightChild=new binaryTreeNode&lt;T&gt;(right[cur]); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //初始化完成 { delete []left; delete []right; return ; } q.pop(); cur=t-&gt;element; }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeNodeNumber() const{//输出二叉树中所有节点为根的子树的节点个数 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的节点个数 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=nodeNumber(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::subtreeHeight() const{//输出二叉树中所有节点为根的子树的高度 int *result=new int[treeSize+1]; //result[i]表示以节点i为根的子树的高度 binaryTreeNode&lt;T&gt; *t=root; int cur; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; //层次遍历 while (t!=NULL) { cur=t-&gt;element; result[cur]=height(t); if(t-&gt;leftChild) q.push(t-&gt;leftChild); if(t-&gt;rightChild) q.push(t-&gt;rightChild); if(!q.empty()) t=q.front(); else //遍历结束 { for(int i=1;i&lt;=treeSize;i++) cout&lt;&lt;result[i]&lt;&lt;&quot; &quot;; delete []result; return ; } q.pop(); }}template &lt;class T&gt;binaryTreeNode&lt;T&gt;* linkedBinaryTree&lt;T&gt;::buildTree(T *pre, T *in, int len){//根据前序序列pre和中序序列in构建二叉树 //len表示序列长度 //返回二叉树的根节点 //序列长度小于等于0，不需要继续构造 if(len&lt;=0) return NULL; binaryTreeNode&lt;T&gt;* subRoot=new binaryTreeNode&lt;T&gt;(pre[0]); //pre[0]为根节点 int index=0; //在中序序列中查找pre[0] for(int i=0;i&lt;len;i++) if(in[i]==pre[0]) { index=i; break; } //递归构造左子树和右子树 subRoot-&gt;leftChild=buildTree(pre+1,in,index); subRoot-&gt;rightChild=buildTree(pre+index+1,in+index+1,len-index-1); return subRoot;}template &lt;class T&gt;void linkedBinaryTree&lt;T&gt;::update(T* pre,T* in,int len){//将构造的二叉树放到对象中，即更新root和treeSize root=buildTree(pre, in, len); treeSize=len;}int main(){ linkedBinaryTree&lt;int&gt; BT; int n; cin&gt;&gt;n; int *pre=new int[n],*in=new int[n]; for(int i=0;i&lt;n;i++) cin&gt;&gt;pre[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;in[i]; BT.update(pre,in,n); BT.postOrderOutput(); delete []pre; delete []in; return 0;} 结果分析1.初始化时需要注意第i行的两个数字a、b表示的是编号为i的节点的左孩子和右孩子，不是位置为i的节点，因此在利用层次遍历进行初始化时，首先将每个节点的左孩子和右孩子分别存入两个数组，然后根据当前节点的element值在数组中找到左孩子和右孩子。2.类的静态数据成员需要在类内定义，在类外进行初始化，如果没有初始化，也就意味着没有对其分配内存，在连接时会因为找不到对应的内存单元导致连接报错。函数指针的初始化的语法格式： 12template &lt;class T&gt;void (*linkedBinaryTree&lt;T&gt;::visit)(binaryTreeNode&lt;T&gt; *)=NULL;","link":"/2020/12/23/DSA/DSA_9/"},{"title":"DSA：（五）数组和矩阵","text":"&emsp;&emsp;本文通过单个线性表（三元组）按照行主次序将稀疏矩阵映射到一维数组中，提供重置、转置、加法、乘法、输入、输出操作。稀疏矩阵类sparseMatrix在arrayList类的基础上实现，对arrayList类的方法进行了一些扩充。在代码实现过程中需要注意OJ对时间复杂度的要求，对代码进行优化。 P1008:稀疏矩阵题目描述 创建稀疏矩阵类（参照课本MatrixTerm三元组定义），采用行主顺序把稀疏矩阵非0元素映射到一维数组中，提供操作:两个稀疏矩阵相加、两个稀疏矩阵相乘、稀疏矩阵的转置、输出矩阵。 键盘输入矩阵的行数、列数，并按行优先顺序输入矩阵的各元素值，建立矩阵。 对建立的矩阵执行相加、相乘、转置的操作，输出操作的结果矩阵。 要求1.数据类型请使用int，本题中所有运算的结果均视作对int型自然溢出。2.可以使用vector等STL中的容器保存稀疏矩阵元素，减少不必要的bug。3.各操作需在稀疏矩阵上进行，充分考虑数据的稀疏性，不得直接或间接转换为二维数组形式计算，否则取消成绩。 操作描述 格式输入第一行一个w代表操作个数，接下来若干行是各个操作，其中保证第一个操作一定为重置矩阵。 输出当执行操作4时，输出矩阵P;当执行操作2或3时，若对应运算不合法，则输出-1。 样例样例1输入12345678910111213141516171819202122232425715 52 1 0 0 00 0 -1 0 00 0 0 0 00 0 -1 0 00 0 0 0 035 542 2 53 5 84 4 25 3 4425 531 1 82 4 43 5 2454 输出1234567891011121314151617185 52 1 0 0 0 0 5 -1 0 0 0 0 0 0 8 0 0 -1 2 0 0 0 4 0 0 5 516 0 0 4 0 0 0 0 20 -2 0 0 0 0 0 0 0 0 0 -2 0 0 0 0 8 5 516 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 20 0 0 0 0 -2 0 -2 8 样例2输入12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828940110 20-1 0 1 0 0 0 0 0 -1 0 0 0 -1 0 -1 0 0 -1 1 -10 0 2 -1 0 0 0 0 0 -1 0 0 0 0 0 0 0 1 -2 01 0 0 0 0 0 0 0 0 0 -1 -2 -1 0 -1 0 0 0 0 00 0 0 1 0 -1 -1 -1 0 0 1 0 0 0 0 0 0 0 -1 00 0 0 1 0 0 0 0 0 1 -1 1 0 0 0 0 -1 0 0 01 0 -1 1 2 0 0 0 1 0 0 0 0 -1 0 1 -1 1 -1 0-1 0 0 0 -1 0 0 0 0 0 -1 0 0 -1 2 0 0 -1 0 0-1 -1 -1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 00 0 0 0 0 0 -3 0 0 0 0 -1 -2 1 0 2 0 -1 -1 0-1 1 0 1 -1 0 0 0 -1 0 -1 0 0 0 0 1 0 0 -1 1210 2072 16 93 7 33 17 46 3 47 12 108 13 610 8 3210 2081 20 14 20 56 5 46 10 107 4 87 6 108 12 99 17 5210 2091 8 43 8 63 17 75 1 105 8 46 9 47 12 79 10 99 17 7310 2073 3 105 18 48 5 28 19 58 20 109 12 310 11 104210 2023 16 44 10 6210 2071 16 82 9 83 8 94 2 44 20 78 10 710 3 4210 2011 19 5210 20101 9 82 15 53 2 104 2 54 3 94 7 106 6 66 14 67 2 79 16 9210 2073 14 54 9 86 19 57 17 78 13 49 6 109 20 15220 1076 9 27 8 107 9 911 1 1012 5 618 4 820 6 4220 10213 2 517 5 10119 192 0 0 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 10 0 1 0 1 -3 0 0 -1 1 -2 0 -2 0 0 1 0 0 0-1 -1 0 0 1 0 0 1 0 -1 0 0 1 1 0 0 0 1 00 0 -1 0 0 -2 -1 0 0 0 1 0 0 1 2 -1 2 0 00 1 0 -1 0 0 -1 0 0 -1 0 0 0 -1 0 -1 0 -1 00 0 0 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 -11 0 -1 1 0 0 -1 0 1 1 0 0 0 0 1 0 1 0 -10 0 0 1 0 0 0 -1 0 0 0 0 0 0 0 0 -1 0 -10 -1 1 0 0 0 0 0 0 0 -1 0 0 0 -1 1 0 0 00 0 -1 0 0 0 0 1 0 -1 2 0 2 -1 -1 0 -1 0 01 0 0 -1 0 0 0 0 0 0 0 0 0 0 -1 1 0 0 00 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 -1-1 0 0 0 2 -1 2 -2 0 0 0 -1 1 0 0 0 0 0 00 0 1 0 0 -1 0 0 0 0 0 0 0 0 0 -1 0 0 -20 0 -1 0 0 1 0 0 1 -1 0 0 0 1 0 0 0 0 10 0 0 0 1 -1 -1 1 1 0 0 0 0 -1 0 0 0 0 00 -1 0 0 0 0 2 0 0 0 0 2 2 0 0 0 0 0 -10 0 0 -1 0 -1 0 0 0 0 0 -1 0 0 0 0 0 0 00 -1 -1 0 0 1 0 -1 1 0 -1 0 0 0 0 0 0 0 14219 1965 5 25 17 512 3 313 15 514 3 515 9 7219 1987 9 110 1 612 2 414 3 914 8 216 7 318 1 118 14 4219 1991 5 31 18 104 15 46 7 911 19 612 2 114 7 614 14 217 9 8219 1974 18 75 9 17 2 611 9 312 16 315 9 216 5 5219 1933 12 417 7 518 16 45219 19117 17 2319 19611 8 511 14 512 19 617 5 417 15 619 19 4219 1971 1 44 12 56 1 97 8 39 18 813 12 216 14 2219 1928 11 712 4 8319 1971 16 53 9 65 15 314 14 1015 9 615 14 315 19 7219 1961 19 25 8 66 16 69 6 610 18 915 7 555219 1966 7 110 7 613 5 515 16 617 9 1019 15 3219 1963 5 44 9 55 15 111 3 517 5 617 7 7219 19114 6 75219 1933 10 84 18 115 15 8219 1945 8 106 9 106 16 614 15 454219 1992 17 34 18 912 3 813 11 1013 19 714 12 415 4 917 8 919 4 5219 1917 17 6 输出12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061-1-1-110 200 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 6 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 5 10 0 0 0 0 0 0 0 0 0 9 0 3 0 0 0 0 7 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 -1-1-1-1-1-1-119 192 0 0 0 0 0 1 0 0 1 0 0 0 1 0 1 1 0 1 0 0 1 0 1 -3 0 0 -1 1 -2 0 -2 0 0 1 0 0 0 -1 -1 0 0 1 0 0 1 0 -1 0 0 1 1 0 0 0 1 0 0 0 -1 0 0 -2 -1 0 0 0 1 0 0 1 2 -1 2 0 0 0 1 0 -1 0 0 -1 0 0 -1 0 0 0 -1 0 -1 0 -1 0 0 0 0 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 -1 1 0 -1 1 0 0 -1 0 1 1 0 0 0 0 1 0 1 0 -1 0 0 0 1 0 0 0 -1 0 0 0 0 0 0 0 0 -1 0 -1 0 -1 1 0 0 0 0 0 0 0 -1 0 0 0 -1 1 0 0 0 0 0 -1 0 0 0 0 1 0 -1 2 0 2 -1 -1 0 -1 0 0 1 0 0 -1 0 0 0 0 0 0 0 0 0 0 -1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 -1 -1 0 0 0 2 -1 2 -2 0 0 0 -1 1 0 0 0 0 0 0 0 0 1 0 0 -1 0 0 0 0 0 0 0 0 0 -1 0 0 -2 0 0 -1 0 0 1 0 0 1 -1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 -1 -1 1 1 0 0 0 0 -1 0 0 0 0 0 0 -1 0 0 0 0 2 0 0 0 0 2 2 0 0 0 0 0 -1 0 0 0 -1 0 -1 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 -1 -1 0 0 1 0 -1 1 0 -1 0 0 0 0 0 0 0 1 19 190 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 样例3输入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085092015 11-22324 -8307 9206 122 -7218 21649 -16209 11639 3813 12960 15895-6355 8061 -4443 9028 -2663 20150 6485 8100 -12939 -1189 -895417884 -3031 -10317 6894 9240 -1078 9344 -16194 -1543 -16063 -15494-19732 3868 -25565 1922 4300 8148 -13256 4611 2077 26163 1073810610 -2944 6357 4205 -12046 2795 13566 18396 11768 -5985 -345525 5251 1 11 2 21 3 21 4 21 5 32 1 12 2 12 3 32 4 22 5 23 1 13 2 13 3 33 4 23 5 14 1 24 2 14 3 34 4 24 5 25 1 25 2 25 3 35 4 25 5 2425 5251 1 21 2 11 3 21 4 11 5 22 1 32 2 22 3 12 4 32 5 13 1 13 2 13 3 13 4 23 5 34 1 24 2 14 3 24 4 34 5 35 1 25 2 25 3 25 4 15 5 325 5251 1 31 2 11 3 11 4 21 5 12 1 12 2 12 3 22 4 22 5 33 1 33 2 13 3 33 4 13 5 14 1 24 2 34 3 24 4 34 5 15 1 15 2 15 3 25 4 15 5 125 5251 1 21 2 21 3 11 4 31 5 22 1 12 2 32 3 32 4 12 5 13 1 23 2 23 3 23 4 13 5 34 1 34 2 14 3 14 4 24 5 25 1 25 2 25 3 15 4 15 5 325 5251 1 21 2 11 3 11 4 21 5 22 1 22 2 32 3 12 4 22 5 23 1 33 2 13 3 33 4 33 5 24 1 34 2 24 3 34 4 24 5 15 1 15 2 25 3 35 4 25 5 2425 5251 1 21 2 31 3 21 4 21 5 32 1 12 2 32 3 22 4 12 5 23 1 13 2 13 3 23 4 33 5 14 1 14 2 24 3 14 4 14 5 15 1 35 2 25 3 25 4 15 5 225 5251 1 31 2 21 3 21 4 31 5 22 1 32 2 22 3 22 4 22 5 33 1 33 2 33 3 13 4 33 5 14 1 24 2 34 3 14 4 34 5 15 1 35 2 35 3 35 4 35 5 235 5251 1 21 2 21 3 11 4 31 5 22 1 12 2 12 3 32 4 32 5 13 1 23 2 13 3 33 4 23 5 14 1 24 2 34 3 24 4 14 5 25 1 15 2 15 3 35 4 15 5 244212 131561 1 31 2 21 3 21 4 31 5 31 6 31 7 11 8 21 9 31 10 21 11 11 12 31 13 32 1 12 2 12 3 22 4 32 5 22 6 22 7 32 8 12 9 12 10 22 11 12 12 12 13 23 1 23 2 23 3 23 4 23 5 13 6 33 7 33 8 23 9 23 10 33 11 23 12 33 13 24 1 34 2 24 3 24 4 24 5 34 6 24 7 24 8 34 9 24 10 24 11 24 12 24 13 35 1 25 2 15 3 35 4 35 5 35 6 25 7 35 8 25 9 15 10 35 11 25 12 35 13 36 1 16 2 36 3 36 4 26 5 16 6 36 7 26 8 36 9 26 10 16 11 36 12 26 13 37 1 27 2 27 3 37 4 17 5 17 6 17 7 27 8 17 9 37 10 17 11 17 12 37 13 38 1 18 2 28 3 18 4 38 5 38 6 28 7 38 8 18 9 28 10 18 11 28 12 38 13 19 1 39 2 39 3 29 4 19 5 39 6 39 7 39 8 19 9 19 10 39 11 29 12 29 13 210 1 310 2 310 3 110 4 110 5 110 6 310 7 210 8 110 9 110 10 310 11 310 12 310 13 211 1 111 2 211 3 211 4 311 5 211 6 111 7 111 8 211 9 311 10 211 11 311 12 211 13 312 1 212 2 312 3 112 4 212 5 212 6 212 7 312 8 312 9 212 10 212 11 112 12 112 13 225 5251 1 11 2 31 3 31 4 11 5 32 1 22 2 22 3 32 4 22 5 13 1 33 2 13 3 13 4 23 5 14 1 14 2 34 3 14 4 14 5 35 1 35 2 25 3 15 4 25 5 125 5251 1 21 2 11 3 21 4 11 5 22 1 12 2 12 3 22 4 22 5 23 1 13 2 13 3 13 4 33 5 34 1 24 2 14 3 34 4 34 5 35 1 25 2 15 3 25 4 15 5 1425 5251 1 21 2 31 3 21 4 31 5 32 1 12 2 22 3 32 4 32 5 23 1 33 2 13 3 33 4 23 5 14 1 34 2 14 3 34 4 24 5 35 1 15 2 15 3 35 4 35 5 2425 5251 1 31 2 11 3 21 4 21 5 12 1 12 2 32 3 32 4 32 5 13 1 13 2 23 3 13 4 13 5 34 1 24 2 24 3 14 4 34 5 15 1 25 2 25 3 35 4 25 5 1 输出123456789101112131415161718192021222324252627282930313233343536373839-15 51 2 2 2 3 1 1 3 2 2 1 1 3 2 1 2 1 3 2 2 2 2 3 2 2 5 516143 13975 16499 16583 13958 14052 12162 14360 14438 12152 12440 10759 12704 12777 10751 15373 13308 15713 15794 13293 17168 14856 17540 17632 14838 5 51945386 1782533 1254468 1903751 1285027 1693395 1551629 1091979 1657151 1118577 1498468 1373016 966290 1466390 989824 1852660 1697571 1194674 1813009 1223776 2068355 1895207 1333773 2024085 1366260 5 51945386 1782533 1254468 1903751 1285027 1693395 1551629 1091979 1657151 1118577 1498468 1373016 966290 1466390 989824 1852660 1697571 1194674 1813009 1223776 2068355 1895207 1333773 2024085 1366260 -1-15 516 11 20 22 23 15 10 19 22 24 14 8 17 15 18 14 9 18 16 17 15 9 19 17 20 5 5192 135 260 234 202 187 130 255 229 198 150 108 202 184 156 156 111 208 188 160 167 119 225 204 173 限制2s, 64MB for each test case. 算法描述&emsp;&emsp;定义结构体matrixTerm，成员为矩阵元素所在的行row，矩阵元素所在的列col，矩阵元素的值value。&emsp;&emsp;在数组描述线性表arrayList的基础上增加方法reSet,set,clear。reSet方法把线性表元素个数改为newSize，必要时增大数组容量，set方法使元素theElement成为表中索引为theIndex的元素，clear方法使表的元素个数为0。增加赋值运算符重载方法，实现一个线性表对当前线性表的赋值。&emsp;&emsp;使用数组存储结构，按照行主映射，封装稀疏矩阵类sparseMatrix，私有成员包括矩阵的行数rows和列数cols，非0项表terms。公有成员包括构造函数，复制构造函数，析构函数，对赋值运算符的重载，重置矩阵，矩阵转置，矩阵相加，矩阵相乘，输入矩阵，输出矩阵。每个方法的具体思想如下：&emsp;&emsp;reSet：重置矩阵。清空terms表，首先读入矩阵的行数和列数，然后按照行列读入元素值，读入后判断元素值是否为0，若不为0，对三元组mTerm的row，col，value赋值，将mTerm插入到terms中的合适位置。&emsp;&emsp;transpose：矩阵转置。创建稀疏矩阵类的对象b用来保存* this的转置，设置转置矩阵的特征，通过colSize和rowNext找出b中每一行的起点，利用迭代器遍历* this的terms表中的每个元素，通过rowNext的记录将b中对应位置的元素设置为mTerm，最后将b赋值给* this。&emsp;&emsp;add：矩阵相加。创建稀疏矩阵类的对象b，调用input方法读入稀疏矩阵。根据矩阵加法的定义判断* this和b是否可以相加，若不能输出-1然后返回，若能，创建稀疏矩阵类的对象c存储相加结果，设置c的特征，首先通过循环利用迭代器遍历* this和b，把相关的项相加，每次相加分为三种情况进行考虑，b项在后，t项在后，两项在同一个位置。循环结束后对* this或b中剩余的元素进行处理，将其插入到c中terms表的合适位置。最后将c赋值给* this。&emsp;&emsp;multiply：矩阵相乘。创建稀疏矩阵类的对象b，调用input方法读入稀疏矩阵。根据矩阵乘法的定义判断* this和b是否可以相乘，若不能输出-1然后返回，若能，创建稀疏矩阵类的对象c存储相乘结果，设置c的特征。与矩阵转置类似，先通过循环寻找b中每一行的项的数目和每一行的起点。通过循环利用迭代器遍历* this，根据rowNext和rowSize在内部嵌套一层循环把相关的项相乘，两层循环结束后将非零元素插入到c中terms表的合适位置。最后将c赋值给* this。&emsp;&emsp;input：输入矩阵。首先输入矩阵的特征rows，cols，numberOfTerms，调用terms的reSet方法，确定terms的长度，然后循环读入每个非零元素，通过terms的set方法将terms对应位置的值设置为mTerm。&emsp;&emsp;output：输出矩阵。首先输出矩阵的行数和列数，然后定义迭代器i和iEnd，设计两层循环，判断当前位置是否是i所指的三元组的位置，若是则表明当前位置是非零元素，输出三元组对应位置的value值，然后i++，若不是则输出0。 C++实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iterator&gt;using namespace std;template &lt;class T&gt;class arrayList{protected: int listSize; //线性表的元素个数 int arrayLength; //一维数组的容量 T* element; //存储线性表的一维数组public: arrayList(int initialCapacity=10); //构造函数 arrayList(const arrayList&amp; theList); //复制构造函数 ~arrayList(); //析构函数 //ADT方法 bool empty() const {return listSize==0;} //判断线性表是否为空 int size() const {return listSize;} //返回线性表的大小 T&amp; get(int theIndex) const; //返回索引为theIndex的元素 int indexOf(const T&amp; theElement) const; //返回元素theElement第一次出现时的索引，若不存在返回-1 void erase(int theIndex); //删除索引为theIndex的元素 void insert(int theIndex,const T&amp; theElement);//在索引为theIndex处插入元素theElement void output(ostream&amp; out) const; //把线性表插入输入流 //其他方法 int capacity() const {return arrayLength;} //返回一维数组容量的大小 //运算符重载 arrayList&lt;T&gt;&amp; operator=(const arrayList&lt;T&gt;&amp; a) {//赋值运算符重载，使用前必须先调用reSet方法 copy(a.element,a.element+a.listSize,element); return *this; } //扩展方法 //用于稀疏矩阵的方法 void reSet(int newSize); //把线性表元素个数改为newSize，必要时增大数组容量 void set(int theIndex,const T&amp; theElement); //使元素theElement成为表中索引为theIndex的元素 void clear(); //使表的元素个数为0 //迭代器 class iterator { protected: T* position; //指向表元素的指针 public: //用C++的typedef语句实现双向迭代器 typedef bidirectional_iterator_tag __iterator_category; typedef T value_type; typedef ptrdiff_t difference_type; typedef T* pointer; typedef T&amp; reference; iterator(T* thePosition=0) //构造函数 { position=thePosition; } //解引用操作符 T&amp; operator* () const {return *position;} T* operator-&gt; () const {return &amp;*position;} //迭代器加法操作 iterator&amp; operator++ ()//前++ { ++position; return *this; } iterator operator++ (int)//后++ { iterator old=*this; ++position; return old; } //迭代器减法操作 iterator&amp; operator-- ()//前-- { --position; return *this; } iterator operator-- (int)//后-- { iterator old=*this; --position; return old; } //相等检验 bool operator!= (const iterator right) const { return position!=right.position; } bool operator== (const iterator right) const { return position==right.position; } }; iterator begin() const {return iterator(element);} iterator end() const {return iterator(element+listSize);} //iterator setIterator(int offset) const {return iterator(element+offset);}};template&lt;class T&gt;arrayList&lt;T&gt;::arrayList(int initialCapacity){//构造函数 arrayLength=initialCapacity; element=new T[arrayLength]; listSize=0;}template&lt;class T&gt;arrayList&lt;T&gt;::arrayList(const arrayList&amp; theList){//复制构造函数 arrayLength=theList.arrayLength; listSize=theList.listSize; element=new T[arrayLength]; copy(theList.element,theList.element+listSize,element);}template&lt;class T&gt;arrayList&lt;T&gt;::~arrayList(){//析构函数 delete []element;}template&lt;class T&gt;T&amp; arrayList&lt;T&gt;::get(int theIndex) const{//返回索引为theIndex的元素 return element[theIndex];}template&lt;class T&gt;int arrayList&lt;T&gt;::indexOf(const T&amp; theElement) const{//返回元素theElement第一次出现时的索引，若不存在返回-1 //查找元素theElement int theIndex=(int) (find(element,element+listSize,theElement)-element); //确定元素theElement是否找到 if(theIndex==listSize) //没有找到 return -1; else //已经找到 return theIndex;}template&lt;class T&gt;void arrayList&lt;T&gt;::erase(int theIndex){//删除索引为theIndex的元素 //移动其索引大于theIndex的元素 copy(element+theIndex+1,element+listSize,element+theIndex); element[--listSize].~T(); //调用析构函数}template&lt;class T&gt;void arrayList&lt;T&gt;::insert(int theIndex,const T&amp; theElement){//在索引为theIndex处插入元素theElement if(listSize==arrayLength) //确定数组是否已满 { T* Nelement=new T[arrayLength*2]; arrayLength=arrayLength*2; copy(element,element+listSize,Nelement); delete []element; element=Nelement; } //把元素向右移动一个位置 copy_backward(element+theIndex,element+listSize,element+listSize+1); element[theIndex]=theElement; listSize++;}template&lt;class T&gt;void arrayList&lt;T&gt;::output(ostream&amp; out) const{//把线性表插入输入流 copy(element,element+listSize,ostream_iterator&lt;T&gt;(cout,&quot; &quot;));}template&lt;class T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; out,const arrayList&lt;T&gt;&amp; x){//重载&lt;&lt; x.output(out); return out;}template &lt;class T&gt;void arrayList&lt;T&gt;::reSet(int newSize){//把线性表元素个数改为newSize，必要时增大数组容量 if(newSize==0) //设置为空表 { for(int i=0;i&lt;listSize;i++) element[i].~T(); listSize=0; return ; } if(listSize==newSize) ; else if(listSize&gt;newSize) { for(int i=newSize;i&lt;listSize;i++) element[i].~T(); listSize=newSize; } else //listSize&lt;newSize { if(arrayLength&gt;=newSize) //数组容量足够 { listSize=newSize; } else //数组容量不够 { T* Nelement=new T[newSize]; delete []element; element=Nelement; arrayLength=newSize; listSize=newSize; } }}template &lt;class T&gt;void arrayList&lt;T&gt;::set(int theIndex,const T&amp; theElement){//使元素theElement成为表中索引为theIndex的元素 element[theIndex]=theElement;}template &lt;class T&gt;void arrayList&lt;T&gt;::clear(){//使表的元素个数为0 for(int i=0;i&lt;listSize;i++) element[i].~T(); listSize=0;}template &lt;class T&gt;struct matrixTerm //三元组{ int row,col; //矩阵元素所在行和所在列 T value; //矩阵元素的值};template &lt;class T&gt;class sparseMatrix{private: int rows,cols; //矩阵的行数和列数 arrayList&lt;matrixTerm&lt;T&gt;&gt; terms; //非0项表public: //构造函数、复制构造函数和析构函数 sparseMatrix() {} sparseMatrix(const sparseMatrix&lt;T&gt;&amp; x):terms(x.terms),rows(x.rows),cols(x.cols) {} ~sparseMatrix() {} //方法 void reSet(); //重置矩阵 void transpose(); //矩阵转置 void add(); //矩阵相加 void mul(); //矩阵相乘 void input(); //输入矩阵 void output(); //输出矩阵 //运算符重载 sparseMatrix&lt;T&gt;&amp; operator=(const sparseMatrix&lt;T&gt;&amp; x);};template &lt;class T&gt;void sparseMatrix&lt;T&gt;::reSet(){//重置矩阵 terms.clear(); //清空表 int value; //输入的矩阵元素值 int mSize=0; //插入三元组线性表的位置 matrixTerm&lt;T&gt; mTerm; cin&gt;&gt;rows&gt;&gt;cols; for(int i=1;i&lt;=rows;i++) { for(int j=1;j&lt;=cols;j++) { cin&gt;&gt;value; if(value!=0) //非零元素插入线性表 { mTerm.row=i; mTerm.col=j; mTerm.value=value; terms.insert(mSize,mTerm); mSize++; } } }}template&lt;class T&gt;void sparseMatrix&lt;T&gt;::transpose(){//b保存*this的转置，再将b赋值给*this sparseMatrix&lt;T&gt; b; //保存*this的转置 //设置转置矩阵的特征 b.cols=rows; b.rows=cols; b.terms.reSet(terms.size()); //初始化以实现转置 int* colSize=new int[cols+1]; int* rowNext=new int[cols+1]; //寻找*this中每一列的项的数目 for(int i=1;i&lt;=cols;i++)//初始化 colSize[i]=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=terms.begin();i!=terms.end();i++) colSize[(*i).col]++; //寻找b中每一行的起点 rowNext[1]=0; for(int i=2;i&lt;=cols;i++) rowNext[i]=rowNext[i-1]+colSize[i-1]; //实施从*this到b的转置复制 matrixTerm&lt;T&gt; mTerm; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=terms.begin();i!=terms.end();i++) { int j=rowNext[(*i).col]++; //b中的位置 mTerm.row=(*i).col; mTerm.col=(*i).row; mTerm.value=(*i).value; b.terms.set(j,mTerm); } delete []colSize; delete []rowNext; *this=b;}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::add(){//计算c=(*this)+b，再将c赋值给*this sparseMatrix&lt;T&gt; b; //和*this做加法的矩阵 b.input(); //不满足矩阵相加的条件 if(rows!=b.rows||cols!=b.cols) { *this=b; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; //printf(&quot;-1\\n&quot;); return ; } //可以进行矩阵相加 sparseMatrix&lt;T&gt; c; //结果矩阵 //设置结果为矩阵c的特征 c.rows=rows; c.cols=cols; c.terms.clear(); int cSize=0; //定义*this和b的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator it=terms.begin(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.begin(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator itEnd=terms.end(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ibEnd=b.terms.end(); //遍历*this和b，把相关的项相加 while(it!=itEnd &amp;&amp; ib!=ibEnd) { //行主索引加上每一行的列数 int tIndex=(*it).row*cols+(*it).col; int bIndex=(*ib).row*cols+(*ib).col; if(tIndex&lt;bIndex) {//b项在后 c.terms.insert(cSize++,*it); it++; } else if(tIndex==bIndex) {//两项在同一个位置 //仅当相加后不为0时加入c if((*it).value+(*ib).value!=0) { matrixTerm&lt;T&gt; mTerm; mTerm.row=(*it).row; mTerm.col=(*it).col; mTerm.value=(*it).value+(*ib).value; c.terms.insert(cSize++,mTerm); } it++; ib++; } else //t项在后 { c.terms.insert(cSize++,*ib); ib++; } } //复制剩余项 for(;it!=itEnd;it++) c.terms.insert(cSize++,*it); for(;ib!=ibEnd;ib++) c.terms.insert(cSize++,*ib); *this=c;}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::mul(){//计算c=(*this)*b，再将c赋值给*this sparseMatrix&lt;T&gt; b; //和*this做乘法的矩阵 b.input(); //不满足矩阵相乘的条件 if(cols!=b.rows) { *this=b; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; //printf(&quot;-1\\n&quot;); return ; } //可以进行矩阵相乘 sparseMatrix&lt;T&gt; c; //结果矩阵 //设置结果为矩阵c的特征 c.rows=rows; c.cols=b.cols; c.terms.clear(); int cSize = 0; //rowSize表示第i行元素的数目，rowNext表示第i行首元素的位置，0号位置不用 int* rowSize=new int[b.rows+1]; int* rowNext=new int[b.rows+1]; //寻找b中每一行的项的数目 for(int i=1;i&lt;=b.rows;i++) //初始化 rowSize[i]=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=b.terms.begin();i!=b.terms.end();i++) rowSize[(*i).row]++; //寻找b中每一行的起点 rowNext[1]=0; for(int i=2;i&lt;=cols;i++) rowNext[i]=rowNext[i-1]+rowSize[i-1]; //定义*this的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator itEnd=terms.end(); matrixTerm&lt;T&gt; sumTerm[c.rows*c.cols]; //保存计算结果 for(int i=0;i&lt;c.rows*c.cols;i++) //初始化 sumTerm[i].value=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator it=terms.begin();it!=itEnd;it++) { /*方法一：定义指向线性表首元素的迭代器，根据rowNext的值移动迭代器到合适位置 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.begin(); for(int i=0;i&lt;rowNext[(*it).col];i++) //移动迭代器 ib++; */ /*方法二：在arrayList中增加方法setIterator，可直接声明指向线性表任意位置的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.setIterator(rowNext[(*it).col]); */ /*方法一和方法二实现相乘 for(int k=0;k&lt;rowSize[(*it).col];k++) //相关的两个元素相乘 { sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].value+=(*it).value * (*ib).value; //确定行数和列数 sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].row=(*it).row; sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].col=(*ib).col; ib++; }*/ //方法三：使用terms的get方法 int iib=rowNext[(*it).col]; for(int k=0;k&lt;rowSize[(*it).col];k++) { sumTerm[(((*it).row-1) * c.cols) + b.terms.get(iib).col-1].value+=(*it).value * b.terms.get(iib).value; //确定行数和列数 sumTerm[(((*it).row-1) * c.cols) + b.terms.get(iib).col-1].row=(*it).row; sumTerm[(((*it).row-1) * c.cols) + b.terms.get(iib).col-1].col=b.terms.get(iib).col; iib++; } } for(int i=0;i&lt;c.rows*c.cols;i++) { if(sumTerm[i].value!=0) //非零元素插入到三元组的线性表中 { c.terms.insert(cSize++, sumTerm[i]); } } delete []rowSize; delete []rowNext; /*矩阵乘法O(n^4)实现方法 //定义*this和b的迭代器 typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator itEnd=terms.end(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ibEnd=b.terms.end(); matrixTerm&lt;T&gt; sumTerm[c.rows*c.cols]; //保存计算结果 for(int i=0;i&lt;c.rows*c.cols;i++) //初始化 sumTerm[i].value=0; for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator it=terms.begin();it!=itEnd;it++) { for(typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator ib=b.terms.begin();ib!=ibEnd;ib++) { if((*it).col==(*ib).row) //相关的两个元素相乘 { sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].value+=(*it).value * (*ib).value; //确定行数和列数 sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].row=(*it).row; sumTerm[(((*it).row-1) * c.cols) + (*ib).col-1].col=(*ib).col; } } } for(int i=0;i&lt;c.rows*c.cols;i++) { if(sumTerm[i].value!=0) //非零元素插入到三元组的线性表中 { c.terms.insert(cSize++, sumTerm[i]); } }*/ *this=c;}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::input(){//输入一个稀疏矩阵 //输入矩阵特征 int numberOfTerms; //非零元素个数 cin&gt;&gt;rows&gt;&gt;cols&gt;&gt;numberOfTerms; terms.reSet(numberOfTerms); matrixTerm&lt;T&gt; mTerm; for(int i=0;i&lt;numberOfTerms;i++) { cin&gt;&gt;mTerm.row&gt;&gt;mTerm.col&gt;&gt;mTerm.value; terms.set(i,mTerm); }}template &lt;class T&gt;void sparseMatrix&lt;T&gt;::output(){//输出一个稀疏矩阵 cout&lt;&lt;rows&lt;&lt;&quot; &quot;&lt;&lt;cols&lt;&lt;endl; //输出矩阵的行数和列数 //printf(&quot;%d %d\\n&quot;,rows,cols); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator i=terms.begin(); typename arrayList&lt;matrixTerm&lt;T&gt;&gt;::iterator iEnd=terms.end(); int val; //元素值 for(int k=1;k&lt;=rows;k++) { for(int j=1;j&lt;=cols;j++) { val=0; if(k==(*i).row &amp;&amp; j==(*i).col &amp;&amp;i!=iEnd) //不是非零元素 { val=(*i).value; //非零元素的值 i++; } cout&lt;&lt;val&lt;&lt;&quot; &quot;; //printf(&quot;%d &quot;,val); } cout&lt;&lt;endl; //printf(&quot;\\n&quot;); }}template &lt;class T&gt;sparseMatrix&lt;T&gt;&amp; sparseMatrix&lt;T&gt;::operator=(const sparseMatrix&lt;T&gt; &amp;x){//赋值运算符重载 if(this==&amp;x) //自我复制 return *this; terms.reSet(x.terms.size()); terms=x.terms; rows=x.rows; cols=x.cols; return *this;}int main(){ int w; //操作个数 int instruction; //指令编号 sparseMatrix&lt;int&gt; s; //创建对象 cin&gt;&gt;w; for(int i=0;i&lt;w;i++) { cin&gt;&gt;instruction; switch(instruction) { case 1: s.reSet(); break; case 2: s.mul(); break; case 3: s.add(); break; case 4: s.output(); break; case 5: s.transpose(); break; } } return 0;} 结果分析1.本题时间限制为2s，只有当稀疏矩阵乘法的时间复杂度为O(n^3)(n为矩阵的行数)时才能保证不超时，O(n^4)最后2个节点会超时。如果对于* this中的每一个元素，遍历b中每一个元素，比较所在行和列判断是否需要相乘，时间复杂度是O(n^4)，n为矩阵行数。优化方法与矩阵转置中的思想类似，先通过循环寻找b中每一行的元素个数和每一行的起点，对于* this中的某一个元素，由* this所在的列直接找出b中对应的行，该行的所有元素即为需要与其相乘的元素，循环次数为b中对应行的元素个数，这样时间复杂度是O(n^3)。2.对“=”的运算符重载实现一个对象赋值给当前对象，不能使用默认的赋值运算符重载函数，因为arrayList类的成员中涉及到T类型的指针element，需要深复制，重新申请内存将element所指的数组中各个元素的值依次复制过来，而默认的运算符重载实现的是浅复制，只复制指针，不能复制指针指向的数组。 PS:最后五个节点是矩阵不稀疏的情况，最大数据量为100次询问，操作为100 * 100矩阵的乘法、加法、转置（大部分是乘法）。","link":"/2020/10/21/DSA/DSA_5/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"简单算法","slug":"简单算法","link":"/tags/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","link":"/tags/Visual-Studio-Code/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"线性表","slug":"线性表","link":"/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"I&#x2F;O","slug":"I-O","link":"/tags/I-O/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"树型结构","slug":"树型结构","link":"/tags/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"索引二叉搜索树","slug":"索引二叉搜索树","link":"/tags/%E7%B4%A2%E5%BC%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"稀疏矩阵","slug":"稀疏矩阵","link":"/tags/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/"}],"categories":[{"name":"Data Structures,Algorithms,and Applications","slug":"Data-Structures-Algorithms-and-Applications","link":"/categories/Data-Structures-Algorithms-and-Applications/"},{"name":"Configuring the Environment","slug":"Configuring-the-Environment","link":"/categories/Configuring-the-Environment/"},{"name":"Hello world","slug":"Hello-world","link":"/categories/Hello-world/"},{"name":"Programming Thinking and Practice","slug":"Programming-Thinking-and-Practice","link":"/categories/Programming-Thinking-and-Practice/"}]}